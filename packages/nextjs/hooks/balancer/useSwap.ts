import { useState } from "react";
import {
  // ChainId,
  ExactInQueryOutput,
  ExactOutQueryOutput,
  Slippage,
  Swap,
  SwapBuildOutputExactIn,
  SwapBuildOutputExactOut,
  SwapKind,
} from "@balancer/sdk";
import { Address } from "viem";
import { useWalletClient } from "wagmi";
import { useTransactor } from "~~/hooks/scaffold-eth";
import { getBlockExplorerTxLink } from "~~/utils/scaffold-eth";

type QuerySwapResponse = Promise<any>;

type SwapTxResponse = Promise<string | undefined>;

type SwapFunctions = {
  querySwap: (pool: Address, tokenIn: any, tokenOut: any) => QuerySwapResponse;
  swap: () => SwapTxResponse;
};

type SwapConfig = {
  slippage: Slippage;
  deadline: bigint;
  wethIsEth: boolean;
};

/**
 * Custom hook for swapping tokens in a pool
 *
 * querySwap: returns updated output amount
 * swap: sends the swap transaction using the call data generated by `querySwap`
 */
export const useSwap = (): SwapFunctions => {
  const [call, setCall] = useState<any>();

  const { data: walletClient } = useWalletClient();
  const writeTx = useTransactor();

  /**
   * @param pool the address of pool
   * @param tokenIn the token to sell
   * @param tokenOut the token to buy
   * @param swapKind the kind of swap (GivenIn or GivenOut)
   */
  const querySwap = async (pool: Address, tokenIn: any, tokenOut: any): QuerySwapResponse => {
    // User defined
    const chainId = walletClient?.chain.id as number;
    const rpcUrl = walletClient?.chain.rpcUrls.default.http[0] as string;

    const swapInput = {
      chainId: chainId,
      swapKind: SwapKind.GivenOut,
      paths: [
        {
          pools: [pool as `0x${string}`],
          tokens: [
            { address: tokenIn.address, decimals: tokenIn.decimals },
            { address: tokenOut.address, decimals: tokenOut.decimals },
          ],
          vaultVersion: 3 as const,
          inputAmountRaw: tokenIn.amountRaw, // used for SwapKind.GivenIn
          outputAmountRaw: tokenOut.amountRaw, // used for SwapKind.GivenOut
        },
      ],
    };

    const swap = new Swap(swapInput);

    const updatedAmount = (await swap.query(rpcUrl)) as ExactInQueryOutput | ExactOutQueryOutput;

    const swapConfig: SwapConfig = {
      slippage: Slippage.fromPercentage("0.1"),
      deadline: 999999999999999999n,
      wethIsEth: false,
    };

    const call = swap.buildCall({
      ...swapConfig,
      queryOutput: updatedAmount,
    }) as SwapBuildOutputExactIn | SwapBuildOutputExactOut;

    setCall(call);

    return {
      updatedAmount,
      call,
    };
  };

  /**
   * @param call the call object from Balancer SDK used to construct the transaction
   */
  const swap = async (): SwapTxResponse => {
    try {
      if (!walletClient) {
        throw new Error("walletClient is undefined");
      }

      const txHashPromise = () =>
        walletClient.sendTransaction({
          account: walletClient.account,
          data: call.call,
          to: call.to,
          value: call.value,
        });

      const hash = await writeTx(txHashPromise, { blockConfirmations: 1 });

      if (!hash) {
        throw new Error("Transaction failed");
      }

      const chainId = await walletClient.getChainId();
      const blockExplorerTxURL = getBlockExplorerTxLink(chainId, hash);
      return blockExplorerTxURL;
    } catch (e) {
      console.error("error", e);
    }
  };

  return { querySwap, swap };
};
