import { useState } from "react";
import { type SwapConfig } from "./types";
import {
  // ChainId,
  ExactInQueryOutput,
  ExactOutQueryOutput,
  Slippage,
  Swap,
  SwapBuildOutputExactIn,
  SwapBuildOutputExactOut, // SwapKind,
} from "@balancer/sdk";
import { useWalletClient } from "wagmi";
import { useTransactor } from "~~/hooks/scaffold-eth";
import { getBlockExplorerTxLink } from "~~/utils/scaffold-eth";

type QuerySwapResponse = Promise<any>;

type SwapTxResponse = Promise<string | undefined>;

type SwapFunctions = {
  querySwap: (swapConfig: SwapConfig) => QuerySwapResponse;
  swap: () => SwapTxResponse;
};

/**
 * Custom hook for swapping tokens in a pool where querySwap sets state of
 * the call object that is used to construct the transaction
 *
 * querySwap: returns updated output amount
 * swap: sends the swap transaction using the call data generated by `querySwap`
 */
export const useSwap = (pool: `0x${string}`): SwapFunctions => {
  const [call, setCall] = useState<any>();

  const { data: walletClient } = useWalletClient();
  const writeTx = useTransactor();

  /**
   * @param swapConfig the configuration object for the swap
   */
  const querySwap = async (swapConfig: SwapConfig): QuerySwapResponse => {
    // User defined
    const chainId = walletClient?.chain.id as number;
    const rpcUrl = walletClient?.chain.rpcUrls.default.http[0] as string;

    const { tokenIn, tokenOut, swapKind } = swapConfig;

    const swapInput = {
      chainId: chainId,
      swapKind: swapKind,
      paths: [
        {
          pools: [pool],
          tokens: [
            {
              address: tokenIn.address,
              decimals: tokenIn.decimals,
            }, // tokenIn
            {
              address: tokenOut.address,
              decimals: tokenOut.decimals,
            }, // tokenOut
          ],
          vaultVersion: 3 as const,
          inputAmountRaw: tokenIn.amountRaw,
          outputAmountRaw: tokenOut.amountRaw,
        },
      ],
    };

    const swap = new Swap(swapInput);

    const updatedAmount = (await swap.query(rpcUrl)) as ExactInQueryOutput | ExactOutQueryOutput;

    const call = swap.buildCall({
      slippage: Slippage.fromPercentage("0.1"),
      deadline: 999999999999999999n, // Deadline for the swap, in this case infinite
      queryOutput: updatedAmount,
      wethIsEth: false,
    }) as SwapBuildOutputExactIn | SwapBuildOutputExactOut;

    setCall(call);

    return {
      updatedAmount,
      call,
    };
  };

  /**
   * @param call the call object from Balancer SDK used to construct the transaction
   */
  const swap = async (): SwapTxResponse => {
    try {
      if (!walletClient) {
        throw new Error("walletClient is undefined");
      }

      const txHashPromise = () =>
        walletClient.sendTransaction({
          account: walletClient.account,
          data: call.call,
          to: call.to,
          value: call.value,
        });

      const hash = await writeTx(txHashPromise, { blockConfirmations: 1 });

      if (!hash) {
        throw new Error("Transaction failed");
      }

      const chainId = await walletClient.getChainId();
      const blockExplorerTxURL = getBlockExplorerTxLink(chainId, hash);
      return blockExplorerTxURL;
    } catch (e) {
      console.error("error", e);
    }
  };

  return { querySwap, swap };
};
