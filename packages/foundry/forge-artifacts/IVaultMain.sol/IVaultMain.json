{"abi":[{"type":"function","name":"addLiquidity","inputs":[{"name":"params","type":"tuple","internalType":"struct AddLiquidityParams","components":[{"name":"pool","type":"address","internalType":"address"},{"name":"to","type":"address","internalType":"address"},{"name":"maxAmountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"minBptAmountOut","type":"uint256","internalType":"uint256"},{"name":"kind","type":"uint8","internalType":"enum AddLiquidityKind"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"amountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmountOut","type":"uint256","internalType":"uint256"},{"name":"returnData","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"},{"type":"function","name":"erc4626BufferWrapOrUnwrap","inputs":[{"name":"params","type":"tuple","internalType":"struct BufferWrapOrUnwrapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"direction","type":"uint8","internalType":"enum WrappingDirection"},{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"amountGivenRaw","type":"uint256","internalType":"uint256"},{"name":"limitRaw","type":"uint256","internalType":"uint256"}]}],"outputs":[{"name":"amountCalculatedRaw","type":"uint256","internalType":"uint256"},{"name":"amountInRaw","type":"uint256","internalType":"uint256"},{"name":"amountOutRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"getAuthorizer","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IAuthorizer"}],"stateMutability":"view"},{"type":"function","name":"getPoolTokenCountAndIndexOfToken","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"token","type":"address","internalType":"contract IERC20"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getVaultExtension","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidity","inputs":[{"name":"params","type":"tuple","internalType":"struct RemoveLiquidityParams","components":[{"name":"pool","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"maxBptAmountIn","type":"uint256","internalType":"uint256"},{"name":"minAmountsOut","type":"uint256[]","internalType":"uint256[]"},{"name":"kind","type":"uint8","internalType":"enum RemoveLiquidityKind"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"bptAmountIn","type":"uint256","internalType":"uint256"},{"name":"amountsOut","type":"uint256[]","internalType":"uint256[]"},{"name":"returnData","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"},{"type":"function","name":"sendTo","inputs":[{"name":"token","type":"address","internalType":"contract IERC20"},{"name":"to","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"settle","inputs":[{"name":"token","type":"address","internalType":"contract IERC20"},{"name":"amountHint","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"credit","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swap","inputs":[{"name":"vaultSwapParams","type":"tuple","internalType":"struct VaultSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"pool","type":"address","internalType":"address"},{"name":"tokenIn","type":"address","internalType":"contract IERC20"},{"name":"tokenOut","type":"address","internalType":"contract IERC20"},{"name":"amountGivenRaw","type":"uint256","internalType":"uint256"},{"name":"limitRaw","type":"uint256","internalType":"uint256"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"amountCalculatedRaw","type":"uint256","internalType":"uint256"},{"name":"amountInRaw","type":"uint256","internalType":"uint256"},{"name":"amountOutRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"unlock","inputs":[{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"result","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":"4af29ec4","erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":"43583be5","getAuthorizer()":"aaabadc5","getPoolTokenCountAndIndexOfToken(address,address)":"c9c1661b","getVaultExtension()":"b9a8effa","removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":"21457897","sendTo(address,address,uint256)":"ae639329","settle(address,uint256)":"15afd409","swap((uint8,address,address,address,uint256,uint256,bytes))":"2bfb780c","unlock(bytes)":"48c89491"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minBptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"enum AddLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct AddLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"enum WrappingDirection\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitRaw\",\"type\":\"uint256\"}],\"internalType\":\"struct BufferWrapOrUnwrapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"erc4626BufferWrapOrUnwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculatedRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizer\",\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoolTokenCountAndIndexOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"enum RemoveLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct RemoveLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountHint\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitRaw\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct VaultSwapParams\",\"name\":\"vaultSwapParams\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculatedRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"These are generally \\\"critical path\\\" functions (swap, add/remove liquidity) that are in the main contract for technical or performance reasons.\",\"kind\":\"dev\",\"methods\":{\"addLiquidity((address,address,uint256[],uint256,uint8,bytes))\":{\"details\":\"Caution should be exercised when adding liquidity because the Vault has the capability to transfer tokens from any user, given that it holds all allowances.\",\"params\":{\"params\":\"Parameters for the add liquidity (see above for struct definition)\"},\"returns\":{\"amountsIn\":\"Actual amounts of input tokens\",\"bptAmountOut\":\"Output pool token amount\",\"returnData\":\"Arbitrary (optional) data with an encoded response from the pool\"}},\"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))\":{\"details\":\"All parameters are given in raw token decimal encoding. It requires the buffer to be initialized, and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.\",\"params\":{\"params\":\"Parameters for the wrap/unwrap operation (see struct definition)\"},\"returns\":{\"amountCalculatedRaw\":\"Calculated swap amount\",\"amountInRaw\":\"Amount of input tokens for the swap\",\"amountOutRaw\":\"Amount of output tokens from the swap\"}},\"getAuthorizer()\":{\"details\":\"The authorizer holds the permissions granted by governance. It is set on Vault deployment, and can be changed through a permissioned call.\",\"returns\":{\"_0\":\"authorizer Address of the authorizer contract\"}},\"getPoolTokenCountAndIndexOfToken(address,address)\":{\"details\":\"Reverts if the pool is not registered, or if the token does not belong to the pool.\",\"params\":{\"pool\":\"Address of the pool\",\"token\":\"Address of the token\"},\"returns\":{\"_0\":\"tokenCount Number of tokens in the pool\",\"_1\":\"index Index corresponding to the given token in the pool's token list\"}},\"getVaultExtension()\":{\"details\":\"Function is in the main Vault contract. The VaultExtension handles less critical or frequently used functions, since delegate calls through the Vault are more expensive than direct calls.\",\"returns\":{\"_0\":\"vaultExtension Address of the VaultExtension\"}},\"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))\":{\"details\":\"Trusted routers can burn pool tokens belonging to any user and require no prior approval from the user. Untrusted routers require prior approval from the user. This is the only function allowed to call _queryModeBalanceIncrease (and only in a query context).\",\"params\":{\"params\":\"Parameters for the remove liquidity (see above for struct definition)\"},\"returns\":{\"amountsOut\":\"Actual amounts of output tokens\",\"bptAmountIn\":\"Actual amount of BPT burned\",\"returnData\":\"Arbitrary (optional) data with an encoded response from the pool\"}},\"sendTo(address,address,uint256)\":{\"details\":\"There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel debts.\",\"params\":{\"amount\":\"Amount of tokens to send\",\"to\":\"Recipient address\",\"token\":\"Address of the token\"}},\"settle(address,uint256)\":{\"details\":\"Protects the caller against leftover dust in the Vault for the token being settled. The caller should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any excess in the Vault balance. If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail. If the given hint is lower than the difference in reserves, the hint is given as credit to the caller. In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would not affect settlement. The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve difference equals current balance of the token minus existing reserves of the token when the function is called.\",\"params\":{\"amountHint\":\"Amount paid as reported by the caller\",\"token\":\"Address of the token\"},\"returns\":{\"credit\":\"Credit received in return of the payment\"}},\"swap((uint8,address,address,address,uint256,uint256,bytes))\":{\"details\":\"All parameters are given in raw token decimal encoding.\",\"params\":{\"vaultSwapParams\":\"Parameters for the swap (see above for struct definition)\"},\"returns\":{\"amountCalculatedRaw\":\"Calculated swap amount\",\"amountInRaw\":\"Amount of input tokens for the swap\",\"amountOutRaw\":\"Amount of output tokens from the swap\"}},\"unlock(bytes)\":{\"details\":\"Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`, meaning all balances for the caller have to be settled at the end.\",\"params\":{\"data\":\"Contains function signature and args to be passed to the msg.sender\"},\"returns\":{\"result\":\"Resulting data from the call\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addLiquidity((address,address,uint256[],uint256,uint8,bytes))\":{\"notice\":\"Adds liquidity to a pool.\"},\"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))\":{\"notice\":\"Wraps/unwraps tokens based on the parameters provided.\"},\"getAuthorizer()\":{\"notice\":\"Returns the Authorizer address.\"},\"getPoolTokenCountAndIndexOfToken(address,address)\":{\"notice\":\"Gets the index of a token in a given pool.\"},\"getVaultExtension()\":{\"notice\":\"Returns the VaultExtension contract address.\"},\"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))\":{\"notice\":\"Removes liquidity from a pool.\"},\"sendTo(address,address,uint256)\":{\"notice\":\"Sends tokens to a recipient.\"},\"settle(address,uint256)\":{\"notice\":\"Settles deltas for a token; must be successful for the current lock to be released.\"},\"swap((uint8,address,address,address,uint256,uint256,bytes))\":{\"notice\":\"Swaps tokens based on provided parameters.\"},\"unlock(bytes)\":{\"notice\":\"Creates a context for a sequence of operations (i.e., \\\"unlocks\\\" the Vault).\"}},\"notice\":\"Interface for functions defined on the main Vault contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":\"IVaultMain\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":999},\"remappings\":[\":@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/\",\":@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/\",\":@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/\",\":@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/\",\":@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@test/=lib/balancer-v3-monorepo/pkg/\",\":ds-test/=../../node_modules/forge-std/lib/ds-test/src/\",\":forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":permit2/=lib/permit2/\",\":pool-weighted/=../pool-weighted/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\":solidity-utils/=../solidity-utils/\",\":vault/=../vault/\"]},\"sources\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452\",\"dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol\":{\"keccak256\":\"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c\",\"dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":{\"keccak256\":\"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6\",\"dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3\",\"dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf\",\"dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323\",\"dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"struct AddLiquidityParams","name":"params","type":"tuple","components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"maxAmountsIn","type":"uint256[]"},{"internalType":"uint256","name":"minBptAmountOut","type":"uint256"},{"internalType":"enum AddLiquidityKind","name":"kind","type":"uint8"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"addLiquidity","outputs":[{"internalType":"uint256[]","name":"amountsIn","type":"uint256[]"},{"internalType":"uint256","name":"bptAmountOut","type":"uint256"},{"internalType":"bytes","name":"returnData","type":"bytes"}]},{"inputs":[{"internalType":"struct BufferWrapOrUnwrapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"enum WrappingDirection","name":"direction","type":"uint8"},{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"amountGivenRaw","type":"uint256"},{"internalType":"uint256","name":"limitRaw","type":"uint256"}]}],"stateMutability":"nonpayable","type":"function","name":"erc4626BufferWrapOrUnwrap","outputs":[{"internalType":"uint256","name":"amountCalculatedRaw","type":"uint256"},{"internalType":"uint256","name":"amountInRaw","type":"uint256"},{"internalType":"uint256","name":"amountOutRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getAuthorizer","outputs":[{"internalType":"contract IAuthorizer","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"contract IERC20","name":"token","type":"address"}],"stateMutability":"view","type":"function","name":"getPoolTokenCountAndIndexOfToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getVaultExtension","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"struct RemoveLiquidityParams","name":"params","type":"tuple","components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256","name":"maxBptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"minAmountsOut","type":"uint256[]"},{"internalType":"enum RemoveLiquidityKind","name":"kind","type":"uint8"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"removeLiquidity","outputs":[{"internalType":"uint256","name":"bptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"},{"internalType":"bytes","name":"returnData","type":"bytes"}]},{"inputs":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"sendTo"},{"inputs":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"uint256","name":"amountHint","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"settle","outputs":[{"internalType":"uint256","name":"credit","type":"uint256"}]},{"inputs":[{"internalType":"struct VaultSwapParams","name":"vaultSwapParams","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"contract IERC20","name":"tokenIn","type":"address"},{"internalType":"contract IERC20","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountGivenRaw","type":"uint256"},{"internalType":"uint256","name":"limitRaw","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"swap","outputs":[{"internalType":"uint256","name":"amountCalculatedRaw","type":"uint256"},{"internalType":"uint256","name":"amountInRaw","type":"uint256"},{"internalType":"uint256","name":"amountOutRaw","type":"uint256"}]},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"unlock","outputs":[{"internalType":"bytes","name":"result","type":"bytes"}]}],"devdoc":{"kind":"dev","methods":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":{"details":"Caution should be exercised when adding liquidity because the Vault has the capability to transfer tokens from any user, given that it holds all allowances.","params":{"params":"Parameters for the add liquidity (see above for struct definition)"},"returns":{"amountsIn":"Actual amounts of input tokens","bptAmountOut":"Output pool token amount","returnData":"Arbitrary (optional) data with an encoded response from the pool"}},"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":{"details":"All parameters are given in raw token decimal encoding. It requires the buffer to be initialized, and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.","params":{"params":"Parameters for the wrap/unwrap operation (see struct definition)"},"returns":{"amountCalculatedRaw":"Calculated swap amount","amountInRaw":"Amount of input tokens for the swap","amountOutRaw":"Amount of output tokens from the swap"}},"getAuthorizer()":{"details":"The authorizer holds the permissions granted by governance. It is set on Vault deployment, and can be changed through a permissioned call.","returns":{"_0":"authorizer Address of the authorizer contract"}},"getPoolTokenCountAndIndexOfToken(address,address)":{"details":"Reverts if the pool is not registered, or if the token does not belong to the pool.","params":{"pool":"Address of the pool","token":"Address of the token"},"returns":{"_0":"tokenCount Number of tokens in the pool","_1":"index Index corresponding to the given token in the pool's token list"}},"getVaultExtension()":{"details":"Function is in the main Vault contract. The VaultExtension handles less critical or frequently used functions, since delegate calls through the Vault are more expensive than direct calls.","returns":{"_0":"vaultExtension Address of the VaultExtension"}},"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":{"details":"Trusted routers can burn pool tokens belonging to any user and require no prior approval from the user. Untrusted routers require prior approval from the user. This is the only function allowed to call _queryModeBalanceIncrease (and only in a query context).","params":{"params":"Parameters for the remove liquidity (see above for struct definition)"},"returns":{"amountsOut":"Actual amounts of output tokens","bptAmountIn":"Actual amount of BPT burned","returnData":"Arbitrary (optional) data with an encoded response from the pool"}},"sendTo(address,address,uint256)":{"details":"There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel debts.","params":{"amount":"Amount of tokens to send","to":"Recipient address","token":"Address of the token"}},"settle(address,uint256)":{"details":"Protects the caller against leftover dust in the Vault for the token being settled. The caller should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any excess in the Vault balance. If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail. If the given hint is lower than the difference in reserves, the hint is given as credit to the caller. In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would not affect settlement. The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve difference equals current balance of the token minus existing reserves of the token when the function is called.","params":{"amountHint":"Amount paid as reported by the caller","token":"Address of the token"},"returns":{"credit":"Credit received in return of the payment"}},"swap((uint8,address,address,address,uint256,uint256,bytes))":{"details":"All parameters are given in raw token decimal encoding.","params":{"vaultSwapParams":"Parameters for the swap (see above for struct definition)"},"returns":{"amountCalculatedRaw":"Calculated swap amount","amountInRaw":"Amount of input tokens for the swap","amountOutRaw":"Amount of output tokens from the swap"}},"unlock(bytes)":{"details":"Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`, meaning all balances for the caller have to be settled at the end.","params":{"data":"Contains function signature and args to be passed to the msg.sender"},"returns":{"result":"Resulting data from the call"}}},"version":1},"userdoc":{"kind":"user","methods":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":{"notice":"Adds liquidity to a pool."},"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":{"notice":"Wraps/unwraps tokens based on the parameters provided."},"getAuthorizer()":{"notice":"Returns the Authorizer address."},"getPoolTokenCountAndIndexOfToken(address,address)":{"notice":"Gets the index of a token in a given pool."},"getVaultExtension()":{"notice":"Returns the VaultExtension contract address."},"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":{"notice":"Removes liquidity from a pool."},"sendTo(address,address,uint256)":{"notice":"Sends tokens to a recipient."},"settle(address,uint256)":{"notice":"Settles deltas for a token; must be successful for the current lock to be released."},"swap((uint8,address,address,address,uint256,uint256,bytes))":{"notice":"Swaps tokens based on provided parameters."},"unlock(bytes)":{"notice":"Creates a context for a sequence of operations (i.e., \"unlocks\" the Vault)."}},"version":1}},"settings":{"remappings":["@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/","@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/","@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/","@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/","@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/","@openzeppelin/=lib/openzeppelin-contracts/","@test/=lib/balancer-v3-monorepo/pkg/","ds-test/=../../node_modules/forge-std/lib/ds-test/src/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","permit2/=lib/permit2/","pool-weighted/=../pool-weighted/","solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/","solidity-utils/=../solidity-utils/","vault/=../vault/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":"IVaultMain"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906","urls":["bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452","dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol":{"keccak256":"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a","urls":["bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c","dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":{"keccak256":"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799","urls":["bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6","dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3","urls":["bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3","dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf"],"license":"GPL-3.0-or-later"},"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol":{"keccak256":"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06","urls":["bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf","dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4","urls":["bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009","dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28","urls":["bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323","dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR"],"license":"MIT"}},"version":1},"id":38}