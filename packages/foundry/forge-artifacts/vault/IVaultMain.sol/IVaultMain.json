{"abi":[{"type":"function","name":"addLiquidity","inputs":[{"name":"params","type":"tuple","internalType":"struct AddLiquidityParams","components":[{"name":"pool","type":"address","internalType":"address"},{"name":"to","type":"address","internalType":"address"},{"name":"maxAmountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"minBptAmountOut","type":"uint256","internalType":"uint256"},{"name":"kind","type":"uint8","internalType":"enum AddLiquidityKind"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"amountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmountOut","type":"uint256","internalType":"uint256"},{"name":"returnData","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"},{"type":"function","name":"erc4626BufferWrapOrUnwrap","inputs":[{"name":"params","type":"tuple","internalType":"struct BufferWrapOrUnwrapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"direction","type":"uint8","internalType":"enum WrappingDirection"},{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"amountGivenRaw","type":"uint256","internalType":"uint256"},{"name":"limitRaw","type":"uint256","internalType":"uint256"}]}],"outputs":[{"name":"amountCalculatedRaw","type":"uint256","internalType":"uint256"},{"name":"amountInRaw","type":"uint256","internalType":"uint256"},{"name":"amountOutRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"getAuthorizer","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IAuthorizer"}],"stateMutability":"view"},{"type":"function","name":"getPoolTokenCountAndIndexOfToken","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"token","type":"address","internalType":"contract IERC20"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"},{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getVaultExtension","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidity","inputs":[{"name":"params","type":"tuple","internalType":"struct RemoveLiquidityParams","components":[{"name":"pool","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"maxBptAmountIn","type":"uint256","internalType":"uint256"},{"name":"minAmountsOut","type":"uint256[]","internalType":"uint256[]"},{"name":"kind","type":"uint8","internalType":"enum RemoveLiquidityKind"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"bptAmountIn","type":"uint256","internalType":"uint256"},{"name":"amountsOut","type":"uint256[]","internalType":"uint256[]"},{"name":"returnData","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"},{"type":"function","name":"sendTo","inputs":[{"name":"token","type":"address","internalType":"contract IERC20"},{"name":"to","type":"address","internalType":"address"},{"name":"amount","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"settle","inputs":[{"name":"token","type":"address","internalType":"contract IERC20"},{"name":"amountHint","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"credit","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swap","inputs":[{"name":"vaultSwapParams","type":"tuple","internalType":"struct VaultSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"pool","type":"address","internalType":"address"},{"name":"tokenIn","type":"address","internalType":"contract IERC20"},{"name":"tokenOut","type":"address","internalType":"contract IERC20"},{"name":"amountGivenRaw","type":"uint256","internalType":"uint256"},{"name":"limitRaw","type":"uint256","internalType":"uint256"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"amountCalculatedRaw","type":"uint256","internalType":"uint256"},{"name":"amountInRaw","type":"uint256","internalType":"uint256"},{"name":"amountOutRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"unlock","inputs":[{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"result","type":"bytes","internalType":"bytes"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":"4af29ec4","erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":"43583be5","getAuthorizer()":"aaabadc5","getPoolTokenCountAndIndexOfToken(address,address)":"c9c1661b","getVaultExtension()":"b9a8effa","removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":"21457897","sendTo(address,address,uint256)":"ae639329","settle(address,uint256)":"15afd409","swap((uint8,address,address,address,uint256,uint256,bytes))":"2bfb780c","unlock(bytes)":"48c89491"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minBptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"enum AddLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct AddLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"enum WrappingDirection\",\"name\":\"direction\",\"type\":\"uint8\"},{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitRaw\",\"type\":\"uint256\"}],\"internalType\":\"struct BufferWrapOrUnwrapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"erc4626BufferWrapOrUnwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculatedRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuthorizer\",\"outputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPoolTokenCountAndIndexOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"enum RemoveLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct RemoveLiquidityParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountHint\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"credit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitRaw\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct VaultSwapParams\",\"name\":\"vaultSwapParams\",\"type\":\"tuple\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculatedRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unlock\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"These are generally \\\"critical path\\\" functions (swap, add/remove liquidity) that are in the main contract for technical or performance reasons.\",\"kind\":\"dev\",\"methods\":{\"addLiquidity((address,address,uint256[],uint256,uint8,bytes))\":{\"details\":\"Caution should be exercised when adding liquidity because the Vault has the capability to transfer tokens from any user, given that it holds all allowances.\",\"params\":{\"params\":\"Parameters for the add liquidity (see above for struct definition)\"},\"returns\":{\"amountsIn\":\"Actual amounts of input tokens\",\"bptAmountOut\":\"Output pool token amount\",\"returnData\":\"Arbitrary (optional) data with an encoded response from the pool\"}},\"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))\":{\"details\":\"All parameters are given in raw token decimal encoding. It requires the buffer to be initialized, and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.\",\"params\":{\"params\":\"Parameters for the wrap/unwrap operation (see struct definition)\"},\"returns\":{\"amountCalculatedRaw\":\"Calculated swap amount\",\"amountInRaw\":\"Amount of input tokens for the swap\",\"amountOutRaw\":\"Amount of output tokens from the swap\"}},\"getAuthorizer()\":{\"details\":\"The authorizer holds the permissions granted by governance. It is set on Vault deployment, and can be changed through a permissioned call.\",\"returns\":{\"_0\":\"authorizer Address of the authorizer contract\"}},\"getPoolTokenCountAndIndexOfToken(address,address)\":{\"details\":\"Reverts if the pool is not registered, or if the token does not belong to the pool.\",\"params\":{\"pool\":\"Address of the pool\",\"token\":\"Address of the token\"},\"returns\":{\"_0\":\"tokenCount Number of tokens in the pool\",\"_1\":\"index Index corresponding to the given token in the pool's token list\"}},\"getVaultExtension()\":{\"details\":\"Function is in the main Vault contract. The VaultExtension handles less critical or frequently used functions, since delegate calls through the Vault are more expensive than direct calls.\",\"returns\":{\"_0\":\"vaultExtension Address of the VaultExtension\"}},\"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))\":{\"details\":\"Trusted routers can burn pool tokens belonging to any user and require no prior approval from the user. Untrusted routers require prior approval from the user. This is the only function allowed to call _queryModeBalanceIncrease (and only in a query context).\",\"params\":{\"params\":\"Parameters for the remove liquidity (see above for struct definition)\"},\"returns\":{\"amountsOut\":\"Actual amounts of output tokens\",\"bptAmountIn\":\"Actual amount of BPT burned\",\"returnData\":\"Arbitrary (optional) data with an encoded response from the pool\"}},\"sendTo(address,address,uint256)\":{\"details\":\"There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel debts.\",\"params\":{\"amount\":\"Amount of tokens to send\",\"to\":\"Recipient address\",\"token\":\"Address of the token\"}},\"settle(address,uint256)\":{\"details\":\"Protects the caller against leftover dust in the Vault for the token being settled. The caller should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any excess in the Vault balance. If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail. If the given hint is lower than the difference in reserves, the hint is given as credit to the caller. In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would not affect settlement. The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve difference equals current balance of the token minus existing reserves of the token when the function is called.\",\"params\":{\"amountHint\":\"Amount paid as reported by the caller\",\"token\":\"Address of the token\"},\"returns\":{\"credit\":\"Credit received in return of the payment\"}},\"swap((uint8,address,address,address,uint256,uint256,bytes))\":{\"details\":\"All parameters are given in raw token decimal encoding.\",\"params\":{\"vaultSwapParams\":\"Parameters for the swap (see above for struct definition)\"},\"returns\":{\"amountCalculatedRaw\":\"Calculated swap amount\",\"amountInRaw\":\"Amount of input tokens for the swap\",\"amountOutRaw\":\"Amount of output tokens from the swap\"}},\"unlock(bytes)\":{\"details\":\"Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`, meaning all balances for the caller have to be settled at the end.\",\"params\":{\"data\":\"Contains function signature and args to be passed to the msg.sender\"},\"returns\":{\"result\":\"Resulting data from the call\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addLiquidity((address,address,uint256[],uint256,uint8,bytes))\":{\"notice\":\"Adds liquidity to a pool.\"},\"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))\":{\"notice\":\"Wraps/unwraps tokens based on the parameters provided.\"},\"getAuthorizer()\":{\"notice\":\"Returns the Authorizer address.\"},\"getPoolTokenCountAndIndexOfToken(address,address)\":{\"notice\":\"Gets the index of a token in a given pool.\"},\"getVaultExtension()\":{\"notice\":\"Returns the VaultExtension contract address.\"},\"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))\":{\"notice\":\"Removes liquidity from a pool.\"},\"sendTo(address,address,uint256)\":{\"notice\":\"Sends tokens to a recipient.\"},\"settle(address,uint256)\":{\"notice\":\"Settles deltas for a token; must be successful for the current lock to be released.\"},\"swap((uint8,address,address,address,uint256,uint256,bytes))\":{\"notice\":\"Swaps tokens based on provided parameters.\"},\"unlock(bytes)\":{\"notice\":\"Creates a context for a sequence of operations (i.e., \\\"unlocks\\\" the Vault).\"}},\"notice\":\"Interface for functions defined on the main Vault contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":\"IVaultMain\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":999},\"remappings\":[\":@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/\",\":@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/\",\":@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/\",\":@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/\",\":@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@test/=lib/balancer-v3-monorepo/pkg/\",\":ds-test/=../../node_modules/forge-std/lib/ds-test/src/\",\":forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":permit2/=lib/permit2/\",\":pool-weighted/=../pool-weighted/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\":solidity-utils/=../solidity-utils/\",\":vault/=../vault/\"]},\"sources\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452\",\"dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol\":{\"keccak256\":\"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c\",\"dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":{\"keccak256\":\"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6\",\"dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3\",\"dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf\",\"dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323\",\"dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"struct AddLiquidityParams","name":"params","type":"tuple","components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256[]","name":"maxAmountsIn","type":"uint256[]"},{"internalType":"uint256","name":"minBptAmountOut","type":"uint256"},{"internalType":"enum AddLiquidityKind","name":"kind","type":"uint8"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"addLiquidity","outputs":[{"internalType":"uint256[]","name":"amountsIn","type":"uint256[]"},{"internalType":"uint256","name":"bptAmountOut","type":"uint256"},{"internalType":"bytes","name":"returnData","type":"bytes"}]},{"inputs":[{"internalType":"struct BufferWrapOrUnwrapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"enum WrappingDirection","name":"direction","type":"uint8"},{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"amountGivenRaw","type":"uint256"},{"internalType":"uint256","name":"limitRaw","type":"uint256"}]}],"stateMutability":"nonpayable","type":"function","name":"erc4626BufferWrapOrUnwrap","outputs":[{"internalType":"uint256","name":"amountCalculatedRaw","type":"uint256"},{"internalType":"uint256","name":"amountInRaw","type":"uint256"},{"internalType":"uint256","name":"amountOutRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getAuthorizer","outputs":[{"internalType":"contract IAuthorizer","name":"","type":"address"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"contract IERC20","name":"token","type":"address"}],"stateMutability":"view","type":"function","name":"getPoolTokenCountAndIndexOfToken","outputs":[{"internalType":"uint256","name":"","type":"uint256"},{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getVaultExtension","outputs":[{"internalType":"address","name":"","type":"address"}]},{"inputs":[{"internalType":"struct RemoveLiquidityParams","name":"params","type":"tuple","components":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256","name":"maxBptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"minAmountsOut","type":"uint256[]"},{"internalType":"enum RemoveLiquidityKind","name":"kind","type":"uint8"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"removeLiquidity","outputs":[{"internalType":"uint256","name":"bptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"amountsOut","type":"uint256[]"},{"internalType":"bytes","name":"returnData","type":"bytes"}]},{"inputs":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"sendTo"},{"inputs":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"uint256","name":"amountHint","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"settle","outputs":[{"internalType":"uint256","name":"credit","type":"uint256"}]},{"inputs":[{"internalType":"struct VaultSwapParams","name":"vaultSwapParams","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"contract IERC20","name":"tokenIn","type":"address"},{"internalType":"contract IERC20","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountGivenRaw","type":"uint256"},{"internalType":"uint256","name":"limitRaw","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"swap","outputs":[{"internalType":"uint256","name":"amountCalculatedRaw","type":"uint256"},{"internalType":"uint256","name":"amountInRaw","type":"uint256"},{"internalType":"uint256","name":"amountOutRaw","type":"uint256"}]},{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"unlock","outputs":[{"internalType":"bytes","name":"result","type":"bytes"}]}],"devdoc":{"kind":"dev","methods":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":{"details":"Caution should be exercised when adding liquidity because the Vault has the capability to transfer tokens from any user, given that it holds all allowances.","params":{"params":"Parameters for the add liquidity (see above for struct definition)"},"returns":{"amountsIn":"Actual amounts of input tokens","bptAmountOut":"Output pool token amount","returnData":"Arbitrary (optional) data with an encoded response from the pool"}},"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":{"details":"All parameters are given in raw token decimal encoding. It requires the buffer to be initialized, and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.","params":{"params":"Parameters for the wrap/unwrap operation (see struct definition)"},"returns":{"amountCalculatedRaw":"Calculated swap amount","amountInRaw":"Amount of input tokens for the swap","amountOutRaw":"Amount of output tokens from the swap"}},"getAuthorizer()":{"details":"The authorizer holds the permissions granted by governance. It is set on Vault deployment, and can be changed through a permissioned call.","returns":{"_0":"authorizer Address of the authorizer contract"}},"getPoolTokenCountAndIndexOfToken(address,address)":{"details":"Reverts if the pool is not registered, or if the token does not belong to the pool.","params":{"pool":"Address of the pool","token":"Address of the token"},"returns":{"_0":"tokenCount Number of tokens in the pool","_1":"index Index corresponding to the given token in the pool's token list"}},"getVaultExtension()":{"details":"Function is in the main Vault contract. The VaultExtension handles less critical or frequently used functions, since delegate calls through the Vault are more expensive than direct calls.","returns":{"_0":"vaultExtension Address of the VaultExtension"}},"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":{"details":"Trusted routers can burn pool tokens belonging to any user and require no prior approval from the user. Untrusted routers require prior approval from the user. This is the only function allowed to call _queryModeBalanceIncrease (and only in a query context).","params":{"params":"Parameters for the remove liquidity (see above for struct definition)"},"returns":{"amountsOut":"Actual amounts of output tokens","bptAmountIn":"Actual amount of BPT burned","returnData":"Arbitrary (optional) data with an encoded response from the pool"}},"sendTo(address,address,uint256)":{"details":"There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel debts.","params":{"amount":"Amount of tokens to send","to":"Recipient address","token":"Address of the token"}},"settle(address,uint256)":{"details":"Protects the caller against leftover dust in the Vault for the token being settled. The caller should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any excess in the Vault balance. If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail. If the given hint is lower than the difference in reserves, the hint is given as credit to the caller. In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would not affect settlement. The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve difference equals current balance of the token minus existing reserves of the token when the function is called.","params":{"amountHint":"Amount paid as reported by the caller","token":"Address of the token"},"returns":{"credit":"Credit received in return of the payment"}},"swap((uint8,address,address,address,uint256,uint256,bytes))":{"details":"All parameters are given in raw token decimal encoding.","params":{"vaultSwapParams":"Parameters for the swap (see above for struct definition)"},"returns":{"amountCalculatedRaw":"Calculated swap amount","amountInRaw":"Amount of input tokens for the swap","amountOutRaw":"Amount of output tokens from the swap"}},"unlock(bytes)":{"details":"Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`, meaning all balances for the caller have to be settled at the end.","params":{"data":"Contains function signature and args to be passed to the msg.sender"},"returns":{"result":"Resulting data from the call"}}},"version":1},"userdoc":{"kind":"user","methods":{"addLiquidity((address,address,uint256[],uint256,uint8,bytes))":{"notice":"Adds liquidity to a pool."},"erc4626BufferWrapOrUnwrap((uint8,uint8,address,uint256,uint256))":{"notice":"Wraps/unwraps tokens based on the parameters provided."},"getAuthorizer()":{"notice":"Returns the Authorizer address."},"getPoolTokenCountAndIndexOfToken(address,address)":{"notice":"Gets the index of a token in a given pool."},"getVaultExtension()":{"notice":"Returns the VaultExtension contract address."},"removeLiquidity((address,address,uint256,uint256[],uint8,bytes))":{"notice":"Removes liquidity from a pool."},"sendTo(address,address,uint256)":{"notice":"Sends tokens to a recipient."},"settle(address,uint256)":{"notice":"Settles deltas for a token; must be successful for the current lock to be released."},"swap((uint8,address,address,address,uint256,uint256,bytes))":{"notice":"Swaps tokens based on provided parameters."},"unlock(bytes)":{"notice":"Creates a context for a sequence of operations (i.e., \"unlocks\" the Vault)."}},"version":1}},"settings":{"remappings":["@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/","@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/","@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/","@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/","@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/","@openzeppelin/=lib/openzeppelin-contracts/","@test/=lib/balancer-v3-monorepo/pkg/","ds-test/=../../node_modules/forge-std/lib/ds-test/src/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","permit2/=lib/permit2/","pool-weighted/=../pool-weighted/","solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/","solidity-utils/=../solidity-utils/","vault/=../vault/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":"IVaultMain"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906","urls":["bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452","dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol":{"keccak256":"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a","urls":["bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c","dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":{"keccak256":"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799","urls":["bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6","dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3","urls":["bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3","dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf"],"license":"GPL-3.0-or-later"},"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol":{"keccak256":"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06","urls":["bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf","dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4","urls":["bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009","dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28","urls":["bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323","dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR"],"license":"MIT"}},"version":1},"ast":{"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol","id":6388,"exportedSymbols":{"AddLiquidityKind":[6632],"AddLiquidityParams":[6648],"AfterSwapParams":[6626],"BufferWrapOrUnwrapParams":[6687],"FEE_BITLENGTH":[6690],"FEE_SCALING_FACTOR":[6696],"HookFlags":[6452],"HooksConfig":[6476],"IAuthorizer":[3638],"IERC20":[52306],"IERC4626":[51483],"IRateProvider":[3612],"IVaultMain":[6387],"LiquidityManagement":[6405],"MAX_FEE_PERCENTAGE":[6693],"PoolConfig":[6430],"PoolConfigBits":[6407],"PoolData":[6554],"PoolRoleAccounts":[6502],"PoolSwapParams":[6597],"RemoveLiquidityKind":[6653],"RemoveLiquidityParams":[6669],"Rounding":[6557],"SwapKind":[6560],"SwapState":[6486],"TokenConfig":[6519],"TokenInfo":[6529],"TokenType":[6506],"VaultState":[6494],"VaultSwapParams":[6579],"WrappingDirection":[6672]},"nodeType":"SourceUnit","src":"46:8618:36","nodes":[{"id":6270,"nodeType":"PragmaDirective","src":"46:24:36","nodes":[],"literals":["solidity","^","0.8",".24"]},{"id":6272,"nodeType":"ImportDirective","src":"72:72:36","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol","file":"@openzeppelin/contracts/token/ERC20/IERC20.sol","nameLocation":"-1:-1:-1","scope":6388,"sourceUnit":52307,"symbolAliases":[{"foreign":{"id":6271,"name":"IERC20","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":52306,"src":"81:6:36","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":6274,"nodeType":"ImportDirective","src":"146:48:36","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol","file":"./IAuthorizer.sol","nameLocation":"-1:-1:-1","scope":6388,"sourceUnit":3639,"symbolAliases":[{"foreign":{"id":6273,"name":"IAuthorizer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3638,"src":"155:11:36","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":6275,"nodeType":"ImportDirective","src":"195:26:36","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol","file":"./VaultTypes.sol","nameLocation":"-1:-1:-1","scope":6388,"sourceUnit":6697,"symbolAliases":[],"unitAlias":""},{"id":6387,"nodeType":"ContractDefinition","src":"456:8207:36","nodes":[{"id":6284,"nodeType":"FunctionDefinition","src":"1141:76:36","nodes":[],"documentation":{"id":6277,"nodeType":"StructuredDocumentation","src":"705:431:36","text":" @notice Creates a context for a sequence of operations (i.e., \"unlocks\" the Vault).\n @dev Performs a callback on msg.sender with arguments provided in `data`. The Callback is `transient`,\n meaning all balances for the caller have to be settled at the end.\n @param data Contains function signature and args to be passed to the msg.sender\n @return result Resulting data from the call"},"functionSelector":"48c89491","implemented":false,"kind":"function","modifiers":[],"name":"unlock","nameLocation":"1150:6:36","parameters":{"id":6280,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6279,"mutability":"mutable","name":"data","nameLocation":"1172:4:36","nodeType":"VariableDeclaration","scope":6284,"src":"1157:19:36","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_bytes_calldata_ptr","typeString":"bytes"},"typeName":{"id":6278,"name":"bytes","nodeType":"ElementaryTypeName","src":"1157:5:36","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1156:21:36"},"returnParameters":{"id":6283,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6282,"mutability":"mutable","name":"result","nameLocation":"1209:6:36","nodeType":"VariableDeclaration","scope":6284,"src":"1196:19:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":6281,"name":"bytes","nodeType":"ElementaryTypeName","src":"1196:5:36","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"1195:21:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6295,"nodeType":"FunctionDefinition","src":"2519:84:36","nodes":[],"documentation":{"id":6285,"nodeType":"StructuredDocumentation","src":"1223:1291:36","text":" @notice Settles deltas for a token; must be successful for the current lock to be released.\n @dev Protects the caller against leftover dust in the Vault for the token being settled. The caller\n should know in advance how many tokens were paid to the Vault, so it can provide it as a hint to discard any\n excess in the Vault balance.\n If the given hint is equal to or higher than the difference in reserves, the difference in reserves is given as\n credit to the caller. If it's higher, the caller sent fewer tokens than expected, so settlement would fail.\n If the given hint is lower than the difference in reserves, the hint is given as credit to the caller.\n In this case, the excess would be absorbed by the Vault (and reflected correctly in the reserves), but would\n not affect settlement.\n The credit supplied by the Vault can be calculated as `min(reserveDifference, amountHint)`, where the reserve\n difference equals current balance of the token minus existing reserves of the token when the function is called.\n @param token Address of the token\n @param amountHint Amount paid as reported by the caller\n @return credit Credit received in return of the payment"},"functionSelector":"15afd409","implemented":false,"kind":"function","modifiers":[],"name":"settle","nameLocation":"2528:6:36","parameters":{"id":6291,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6288,"mutability":"mutable","name":"token","nameLocation":"2542:5:36","nodeType":"VariableDeclaration","scope":6295,"src":"2535:12:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"},"typeName":{"id":6287,"nodeType":"UserDefinedTypeName","pathNode":{"id":6286,"name":"IERC20","nameLocations":["2535:6:36"],"nodeType":"IdentifierPath","referencedDeclaration":52306,"src":"2535:6:36"},"referencedDeclaration":52306,"src":"2535:6:36","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"}},"visibility":"internal"},{"constant":false,"id":6290,"mutability":"mutable","name":"amountHint","nameLocation":"2557:10:36","nodeType":"VariableDeclaration","scope":6295,"src":"2549:18:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6289,"name":"uint256","nodeType":"ElementaryTypeName","src":"2549:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2534:34:36"},"returnParameters":{"id":6294,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6293,"mutability":"mutable","name":"credit","nameLocation":"2595:6:36","nodeType":"VariableDeclaration","scope":6295,"src":"2587:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6292,"name":"uint256","nodeType":"ElementaryTypeName","src":"2587:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2586:16:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6306,"nodeType":"FunctionDefinition","src":"2929:67:36","nodes":[],"documentation":{"id":6296,"nodeType":"StructuredDocumentation","src":"2609:315:36","text":" @notice Sends tokens to a recipient.\n @dev There is no inverse operation for this function. Transfer funds to the Vault and call `settle` to cancel\n debts.\n @param token Address of the token\n @param to Recipient address\n @param amount Amount of tokens to send"},"functionSelector":"ae639329","implemented":false,"kind":"function","modifiers":[],"name":"sendTo","nameLocation":"2938:6:36","parameters":{"id":6304,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6299,"mutability":"mutable","name":"token","nameLocation":"2952:5:36","nodeType":"VariableDeclaration","scope":6306,"src":"2945:12:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"},"typeName":{"id":6298,"nodeType":"UserDefinedTypeName","pathNode":{"id":6297,"name":"IERC20","nameLocations":["2945:6:36"],"nodeType":"IdentifierPath","referencedDeclaration":52306,"src":"2945:6:36"},"referencedDeclaration":52306,"src":"2945:6:36","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"}},"visibility":"internal"},{"constant":false,"id":6301,"mutability":"mutable","name":"to","nameLocation":"2967:2:36","nodeType":"VariableDeclaration","scope":6306,"src":"2959:10:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":6300,"name":"address","nodeType":"ElementaryTypeName","src":"2959:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":6303,"mutability":"mutable","name":"amount","nameLocation":"2979:6:36","nodeType":"VariableDeclaration","scope":6306,"src":"2971:14:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6302,"name":"uint256","nodeType":"ElementaryTypeName","src":"2971:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2944:42:36"},"returnParameters":{"id":6305,"nodeType":"ParameterList","parameters":[],"src":"2995:0:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6319,"nodeType":"FunctionDefinition","src":"3627:158:36","nodes":[],"documentation":{"id":6307,"nodeType":"StructuredDocumentation","src":"3210:412:36","text":" @notice Swaps tokens based on provided parameters.\n @dev All parameters are given in raw token decimal encoding.\n @param vaultSwapParams Parameters for the swap (see above for struct definition)\n @return amountCalculatedRaw Calculated swap amount\n @return amountInRaw Amount of input tokens for the swap\n @return amountOutRaw Amount of output tokens from the swap"},"functionSelector":"2bfb780c","implemented":false,"kind":"function","modifiers":[],"name":"swap","nameLocation":"3636:4:36","parameters":{"id":6311,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6310,"mutability":"mutable","name":"vaultSwapParams","nameLocation":"3673:15:36","nodeType":"VariableDeclaration","scope":6319,"src":"3650:38:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_VaultSwapParams_$6579_memory_ptr","typeString":"struct VaultSwapParams"},"typeName":{"id":6309,"nodeType":"UserDefinedTypeName","pathNode":{"id":6308,"name":"VaultSwapParams","nameLocations":["3650:15:36"],"nodeType":"IdentifierPath","referencedDeclaration":6579,"src":"3650:15:36"},"referencedDeclaration":6579,"src":"3650:15:36","typeDescriptions":{"typeIdentifier":"t_struct$_VaultSwapParams_$6579_storage_ptr","typeString":"struct VaultSwapParams"}},"visibility":"internal"}],"src":"3640:54:36"},"returnParameters":{"id":6318,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6313,"mutability":"mutable","name":"amountCalculatedRaw","nameLocation":"3721:19:36","nodeType":"VariableDeclaration","scope":6319,"src":"3713:27:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6312,"name":"uint256","nodeType":"ElementaryTypeName","src":"3713:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6315,"mutability":"mutable","name":"amountInRaw","nameLocation":"3750:11:36","nodeType":"VariableDeclaration","scope":6319,"src":"3742:19:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6314,"name":"uint256","nodeType":"ElementaryTypeName","src":"3742:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6317,"mutability":"mutable","name":"amountOutRaw","nameLocation":"3771:12:36","nodeType":"VariableDeclaration","scope":6319,"src":"3763:20:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6316,"name":"uint256","nodeType":"ElementaryTypeName","src":"3763:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3712:72:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6333,"nodeType":"FunctionDefinition","src":"4531:163:36","nodes":[],"documentation":{"id":6320,"nodeType":"StructuredDocumentation","src":"4003:523:36","text":" @notice Adds liquidity to a pool.\n @dev Caution should be exercised when adding liquidity because the Vault has the capability\n to transfer tokens from any user, given that it holds all allowances.\n @param params Parameters for the add liquidity (see above for struct definition)\n @return amountsIn Actual amounts of input tokens\n @return bptAmountOut Output pool token amount\n @return returnData Arbitrary (optional) data with an encoded response from the pool"},"functionSelector":"4af29ec4","implemented":false,"kind":"function","modifiers":[],"name":"addLiquidity","nameLocation":"4540:12:36","parameters":{"id":6324,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6323,"mutability":"mutable","name":"params","nameLocation":"4588:6:36","nodeType":"VariableDeclaration","scope":6333,"src":"4562:32:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_AddLiquidityParams_$6648_memory_ptr","typeString":"struct AddLiquidityParams"},"typeName":{"id":6322,"nodeType":"UserDefinedTypeName","pathNode":{"id":6321,"name":"AddLiquidityParams","nameLocations":["4562:18:36"],"nodeType":"IdentifierPath","referencedDeclaration":6648,"src":"4562:18:36"},"referencedDeclaration":6648,"src":"4562:18:36","typeDescriptions":{"typeIdentifier":"t_struct$_AddLiquidityParams_$6648_storage_ptr","typeString":"struct AddLiquidityParams"}},"visibility":"internal"}],"src":"4552:48:36"},"returnParameters":{"id":6332,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6327,"mutability":"mutable","name":"amountsIn","nameLocation":"4636:9:36","nodeType":"VariableDeclaration","scope":6333,"src":"4619:26:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":6325,"name":"uint256","nodeType":"ElementaryTypeName","src":"4619:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":6326,"nodeType":"ArrayTypeName","src":"4619:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":6329,"mutability":"mutable","name":"bptAmountOut","nameLocation":"4655:12:36","nodeType":"VariableDeclaration","scope":6333,"src":"4647:20:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6328,"name":"uint256","nodeType":"ElementaryTypeName","src":"4647:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6331,"mutability":"mutable","name":"returnData","nameLocation":"4682:10:36","nodeType":"VariableDeclaration","scope":6333,"src":"4669:23:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":6330,"name":"bytes","nodeType":"ElementaryTypeName","src":"4669:5:36","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"4618:75:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6347,"nodeType":"FunctionDefinition","src":"5562:169:36","nodes":[],"documentation":{"id":6334,"nodeType":"StructuredDocumentation","src":"4913:644:36","text":" @notice Removes liquidity from a pool.\n @dev Trusted routers can burn pool tokens belonging to any user and require no prior approval from the user.\n Untrusted routers require prior approval from the user. This is the only function allowed to call\n _queryModeBalanceIncrease (and only in a query context).\n @param params Parameters for the remove liquidity (see above for struct definition)\n @return bptAmountIn Actual amount of BPT burned\n @return amountsOut Actual amounts of output tokens\n @return returnData Arbitrary (optional) data with an encoded response from the pool"},"functionSelector":"21457897","implemented":false,"kind":"function","modifiers":[],"name":"removeLiquidity","nameLocation":"5571:15:36","parameters":{"id":6338,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6337,"mutability":"mutable","name":"params","nameLocation":"5625:6:36","nodeType":"VariableDeclaration","scope":6347,"src":"5596:35:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_RemoveLiquidityParams_$6669_memory_ptr","typeString":"struct RemoveLiquidityParams"},"typeName":{"id":6336,"nodeType":"UserDefinedTypeName","pathNode":{"id":6335,"name":"RemoveLiquidityParams","nameLocations":["5596:21:36"],"nodeType":"IdentifierPath","referencedDeclaration":6669,"src":"5596:21:36"},"referencedDeclaration":6669,"src":"5596:21:36","typeDescriptions":{"typeIdentifier":"t_struct$_RemoveLiquidityParams_$6669_storage_ptr","typeString":"struct RemoveLiquidityParams"}},"visibility":"internal"}],"src":"5586:51:36"},"returnParameters":{"id":6346,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6340,"mutability":"mutable","name":"bptAmountIn","nameLocation":"5664:11:36","nodeType":"VariableDeclaration","scope":6347,"src":"5656:19:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6339,"name":"uint256","nodeType":"ElementaryTypeName","src":"5656:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6343,"mutability":"mutable","name":"amountsOut","nameLocation":"5694:10:36","nodeType":"VariableDeclaration","scope":6347,"src":"5677:27:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":6341,"name":"uint256","nodeType":"ElementaryTypeName","src":"5677:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":6342,"nodeType":"ArrayTypeName","src":"5677:9:36","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":6345,"mutability":"mutable","name":"returnData","nameLocation":"5719:10:36","nodeType":"VariableDeclaration","scope":6347,"src":"5706:23:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_bytes_memory_ptr","typeString":"bytes"},"typeName":{"id":6344,"name":"bytes","nodeType":"ElementaryTypeName","src":"5706:5:36","typeDescriptions":{"typeIdentifier":"t_bytes_storage_ptr","typeString":"bytes"}},"visibility":"internal"}],"src":"5655:75:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6360,"nodeType":"FunctionDefinition","src":"6351:111:36","nodes":[],"documentation":{"id":6348,"nodeType":"StructuredDocumentation","src":"5961:385:36","text":" @notice Gets the index of a token in a given pool.\n @dev Reverts if the pool is not registered, or if the token does not belong to the pool.\n @param pool Address of the pool\n @param token Address of the token\n @return tokenCount Number of tokens in the pool\n @return index Index corresponding to the given token in the pool's token list"},"functionSelector":"c9c1661b","implemented":false,"kind":"function","modifiers":[],"name":"getPoolTokenCountAndIndexOfToken","nameLocation":"6360:32:36","parameters":{"id":6354,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6350,"mutability":"mutable","name":"pool","nameLocation":"6401:4:36","nodeType":"VariableDeclaration","scope":6360,"src":"6393:12:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":6349,"name":"address","nodeType":"ElementaryTypeName","src":"6393:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":6353,"mutability":"mutable","name":"token","nameLocation":"6414:5:36","nodeType":"VariableDeclaration","scope":6360,"src":"6407:12:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"},"typeName":{"id":6352,"nodeType":"UserDefinedTypeName","pathNode":{"id":6351,"name":"IERC20","nameLocations":["6407:6:36"],"nodeType":"IdentifierPath","referencedDeclaration":52306,"src":"6407:6:36"},"referencedDeclaration":52306,"src":"6407:6:36","typeDescriptions":{"typeIdentifier":"t_contract$_IERC20_$52306","typeString":"contract IERC20"}},"visibility":"internal"}],"src":"6392:28:36"},"returnParameters":{"id":6359,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6356,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":6360,"src":"6444:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6355,"name":"uint256","nodeType":"ElementaryTypeName","src":"6444:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6358,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":6360,"src":"6453:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6357,"name":"uint256","nodeType":"ElementaryTypeName","src":"6453:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"6443:18:36"},"scope":6387,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":6373,"nodeType":"FunctionDefinition","src":"7269:179:36","nodes":[],"documentation":{"id":6361,"nodeType":"StructuredDocumentation","src":"6689:575:36","text":" @notice Wraps/unwraps tokens based on the parameters provided.\n @dev All parameters are given in raw token decimal encoding. It requires the buffer to be initialized,\n and uses the internal wrapped token buffer when it has enough liquidity to avoid external calls.\n @param params Parameters for the wrap/unwrap operation (see struct definition)\n @return amountCalculatedRaw Calculated swap amount\n @return amountInRaw Amount of input tokens for the swap\n @return amountOutRaw Amount of output tokens from the swap"},"functionSelector":"43583be5","implemented":false,"kind":"function","modifiers":[],"name":"erc4626BufferWrapOrUnwrap","nameLocation":"7278:25:36","parameters":{"id":6365,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6364,"mutability":"mutable","name":"params","nameLocation":"7345:6:36","nodeType":"VariableDeclaration","scope":6373,"src":"7313:38:36","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_struct$_BufferWrapOrUnwrapParams_$6687_memory_ptr","typeString":"struct BufferWrapOrUnwrapParams"},"typeName":{"id":6363,"nodeType":"UserDefinedTypeName","pathNode":{"id":6362,"name":"BufferWrapOrUnwrapParams","nameLocations":["7313:24:36"],"nodeType":"IdentifierPath","referencedDeclaration":6687,"src":"7313:24:36"},"referencedDeclaration":6687,"src":"7313:24:36","typeDescriptions":{"typeIdentifier":"t_struct$_BufferWrapOrUnwrapParams_$6687_storage_ptr","typeString":"struct BufferWrapOrUnwrapParams"}},"visibility":"internal"}],"src":"7303:54:36"},"returnParameters":{"id":6372,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6367,"mutability":"mutable","name":"amountCalculatedRaw","nameLocation":"7384:19:36","nodeType":"VariableDeclaration","scope":6373,"src":"7376:27:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6366,"name":"uint256","nodeType":"ElementaryTypeName","src":"7376:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6369,"mutability":"mutable","name":"amountInRaw","nameLocation":"7413:11:36","nodeType":"VariableDeclaration","scope":6373,"src":"7405:19:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6368,"name":"uint256","nodeType":"ElementaryTypeName","src":"7405:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":6371,"mutability":"mutable","name":"amountOutRaw","nameLocation":"7434:12:36","nodeType":"VariableDeclaration","scope":6373,"src":"7426:20:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":6370,"name":"uint256","nodeType":"ElementaryTypeName","src":"7426:7:36","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"7375:72:36"},"scope":6387,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":6380,"nodeType":"FunctionDefinition","src":"7961:61:36","nodes":[],"documentation":{"id":6374,"nodeType":"StructuredDocumentation","src":"7672:284:36","text":" @notice Returns the Authorizer address.\n @dev The authorizer holds the permissions granted by governance. It is set on Vault deployment,\n and can be changed through a permissioned call.\n @return authorizer Address of the authorizer contract"},"functionSelector":"aaabadc5","implemented":false,"kind":"function","modifiers":[],"name":"getAuthorizer","nameLocation":"7970:13:36","parameters":{"id":6375,"nodeType":"ParameterList","parameters":[],"src":"7983:2:36"},"returnParameters":{"id":6379,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6378,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":6380,"src":"8009:11:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IAuthorizer_$3638","typeString":"contract IAuthorizer"},"typeName":{"id":6377,"nodeType":"UserDefinedTypeName","pathNode":{"id":6376,"name":"IAuthorizer","nameLocations":["8009:11:36"],"nodeType":"IdentifierPath","referencedDeclaration":3638,"src":"8009:11:36"},"referencedDeclaration":3638,"src":"8009:11:36","typeDescriptions":{"typeIdentifier":"t_contract$_IAuthorizer_$3638","typeString":"contract IAuthorizer"}},"visibility":"internal"}],"src":"8008:13:36"},"scope":6387,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":6386,"nodeType":"FunctionDefinition","src":"8600:61:36","nodes":[],"documentation":{"id":6381,"nodeType":"StructuredDocumentation","src":"8250:345:36","text":" @notice Returns the VaultExtension contract address.\n @dev Function is in the main Vault contract. The VaultExtension handles less critical or frequently used\n functions, since delegate calls through the Vault are more expensive than direct calls.\n @return vaultExtension Address of the VaultExtension"},"functionSelector":"b9a8effa","implemented":false,"kind":"function","modifiers":[],"name":"getVaultExtension","nameLocation":"8609:17:36","parameters":{"id":6382,"nodeType":"ParameterList","parameters":[],"src":"8626:2:36"},"returnParameters":{"id":6385,"nodeType":"ParameterList","parameters":[{"constant":false,"id":6384,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":6386,"src":"8652:7:36","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":6383,"name":"address","nodeType":"ElementaryTypeName","src":"8652:7:36","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"8651:9:36"},"scope":6387,"stateMutability":"view","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[],"canonicalName":"IVaultMain","contractDependencies":[],"contractKind":"interface","documentation":{"id":6276,"nodeType":"StructuredDocumentation","src":"223:232:36","text":" @notice Interface for functions defined on the main Vault contract.\n @dev These are generally \"critical path\" functions (swap, add/remove liquidity) that are in the main contract\n for technical or performance reasons."},"fullyImplemented":false,"linearizedBaseContracts":[6387],"name":"IVaultMain","nameLocation":"466:10:36","scope":6388,"usedErrors":[],"usedEvents":[]}],"license":"GPL-3.0-or-later"},"id":36}