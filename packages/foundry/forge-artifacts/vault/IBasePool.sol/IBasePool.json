{"abi":[{"type":"function","name":"computeBalance","inputs":[{"name":"balancesLiveScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"tokenInIndex","type":"uint256","internalType":"uint256"},{"name":"invariantRatio","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"newBalance","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"computeInvariant","inputs":[{"name":"balancesLiveScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"rounding","type":"uint8","internalType":"enum Rounding"}],"outputs":[{"name":"invariant","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMaximumInvariantRatio","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMaximumSwapFeePercentage","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMinimumInvariantRatio","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMinimumSwapFeePercentage","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"onSwap","inputs":[{"name":"params","type":"tuple","internalType":"struct PoolSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"amountGivenScaled18","type":"uint256","internalType":"uint256"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"indexIn","type":"uint256","internalType":"uint256"},{"name":"indexOut","type":"uint256","internalType":"uint256"},{"name":"router","type":"address","internalType":"address"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"amountCalculatedScaled18","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"computeBalance(uint256[],uint256,uint256)":"16a0b3e0","computeInvariant(uint256[],uint8)":"984de9e8","getMaximumInvariantRatio()":"273c1adf","getMaximumSwapFeePercentage()":"654cf15d","getMinimumInvariantRatio()":"b677fa56","getMinimumSwapFeePercentage()":"ce20ece7","onSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes))":"72c98186"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balancesLiveScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tokenInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invariantRatio\",\"type\":\"uint256\"}],\"name\":\"computeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balancesLiveScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Rounding\",\"name\":\"rounding\",\"type\":\"uint8\"}],\"name\":\"computeInvariant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumInvariantRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumSwapFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumInvariantRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumSwapFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"indexIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolSwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"onSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountCalculatedScaled18\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"All pool types should implement this interface. Note that it also requires implementation of: - `ISwapFeePercentageBounds` to specify the minimum and maximum swap fee percentages. - `IUnbalancedLiquidityInvariantRatioBounds` to specify how much the invariant can change during an unbalanced liquidity operation.\",\"kind\":\"dev\",\"methods\":{\"computeBalance(uint256[],uint256,uint256)\":{\"details\":\"Computes the new balance of a token after an operation, given the invariant growth ratio and all other balances. Similar to V2's `_getTokenBalanceGivenInvariantAndAllOtherBalances` in StableMath. The pool must round up for the Vault to round in the protocol's favor when calling this function.\",\"params\":{\"balancesLiveScaled18\":\"Token balances after paying yield fees, applying decimal scaling and rates\",\"invariantRatio\":\"The ratio of the new invariant (after an operation) to the old\",\"tokenInIndex\":\"The index of the token we're computing the balance for, sorted in token registration order\"},\"returns\":{\"newBalance\":\"The new balance of the selected token, after the operation\"}},\"computeInvariant(uint256[],uint8)\":{\"details\":\"This function computes the invariant based on current balances (and potentially other pool state). The rounding direction must be respected for the Vault to round in the pool's favor when calling this function. If the invariant computation involves no precision loss (e.g. simple sum of balances), the same result can be returned for both rounding directions.\",\"params\":{\"balancesLiveScaled18\":\"Token balances after paying yield fees, applying decimal scaling and rates\",\"rounding\":\"Rounding direction to consider when computing the invariant\"},\"returns\":{\"invariant\":\"The calculated invariant of the pool, represented as a uint256\"}},\"getMaximumInvariantRatio()\":{\"returns\":{\"_0\":\"maximumInvariantRatio The maximum invariant ratio for a pool during unbalanced add liquidity\"}},\"getMaximumSwapFeePercentage()\":{\"returns\":{\"_0\":\"maximumSwapFeePercentage The maximum swap fee percentage for a pool\"}},\"getMinimumInvariantRatio()\":{\"returns\":{\"_0\":\"minimumInvariantRatio The minimum invariant ratio for a pool during unbalanced remove liquidity\"}},\"getMinimumSwapFeePercentage()\":{\"returns\":{\"_0\":\"minimumSwapFeePercentage The minimum swap fee percentage for a pool\"}},\"onSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes))\":{\"params\":{\"params\":\"Swap parameters (see above for struct definition)\"},\"returns\":{\"amountCalculatedScaled18\":\"Calculated amount for the swap operation\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"computeInvariant(uint256[],uint8)\":{\"notice\":\"Computes the pool's invariant.\"},\"onSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes))\":{\"notice\":\"Execute a swap in the pool.\"}},\"notice\":\"Base interface for a Balancer Pool.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IBasePool.sol\":\"IBasePool\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":999},\"remappings\":[\":@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/\",\":@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/\",\":@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/\",\":@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/\",\":@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@test/=lib/balancer-v3-monorepo/pkg/\",\":ds-test/=../../node_modules/forge-std/lib/ds-test/src/\",\":forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":permit2/=lib/permit2/\",\":pool-weighted/=../pool-weighted/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\":solidity-utils/=../solidity-utils/\",\":vault/=../vault/\"]},\"sources\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452\",\"dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IBasePool.sol\":{\"keccak256\":\"0xef858279c090af39f444432a75cad248c47429a0ac1dc5e93997bd4a628cc1a6\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://c784f91edf7f34d3d827b4e93d1126546c8d4bee60a14cd80fcd219a2ae30fe5\",\"dweb:/ipfs/QmYYFun8MYfk6HKxsrkg2LYHCPGa7ZcAZPEatmHL7C5rtC\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/ISwapFeePercentageBounds.sol\":{\"keccak256\":\"0x566aae4dcbf852199e165378977e6e49009184790e1c9cfd8cd6ddd7b9cbc3d7\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ce904a16c7fa36833b0e055ce8d7d15fba113b8990eab958d7f1f06faf8e7d3c\",\"dweb:/ipfs/QmRKEQaU7sKuw93Dcj4vtxVqexvEU5m5u6aQBZE8eMKQN8\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IUnbalancedLiquidityInvariantRatioBounds.sol\":{\"keccak256\":\"0xc31c0c3cefc3c8bfb7f57a8d53b030bcee5494fe3c8fd6b2749c00e0fb8da592\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://9a88b239a1f9af02e0d3aa60eebab8842aced2605a92be6431cdf2ed5a337ba6\",\"dweb:/ipfs/QmdJnjg7KQQ2ieU29fuU5yjdq5BHHz59e9ts4PD2fMfVx1\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3\",\"dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf\",\"dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323\",\"dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256[]","name":"balancesLiveScaled18","type":"uint256[]"},{"internalType":"uint256","name":"tokenInIndex","type":"uint256"},{"internalType":"uint256","name":"invariantRatio","type":"uint256"}],"stateMutability":"view","type":"function","name":"computeBalance","outputs":[{"internalType":"uint256","name":"newBalance","type":"uint256"}]},{"inputs":[{"internalType":"uint256[]","name":"balancesLiveScaled18","type":"uint256[]"},{"internalType":"enum Rounding","name":"rounding","type":"uint8"}],"stateMutability":"view","type":"function","name":"computeInvariant","outputs":[{"internalType":"uint256","name":"invariant","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMaximumInvariantRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMaximumSwapFeePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumInvariantRatio","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumSwapFeePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"struct PoolSwapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"uint256","name":"amountGivenScaled18","type":"uint256"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"uint256","name":"indexIn","type":"uint256"},{"internalType":"uint256","name":"indexOut","type":"uint256"},{"internalType":"address","name":"router","type":"address"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"onSwap","outputs":[{"internalType":"uint256","name":"amountCalculatedScaled18","type":"uint256"}]}],"devdoc":{"kind":"dev","methods":{"computeBalance(uint256[],uint256,uint256)":{"details":"Computes the new balance of a token after an operation, given the invariant growth ratio and all other balances. Similar to V2's `_getTokenBalanceGivenInvariantAndAllOtherBalances` in StableMath. The pool must round up for the Vault to round in the protocol's favor when calling this function.","params":{"balancesLiveScaled18":"Token balances after paying yield fees, applying decimal scaling and rates","invariantRatio":"The ratio of the new invariant (after an operation) to the old","tokenInIndex":"The index of the token we're computing the balance for, sorted in token registration order"},"returns":{"newBalance":"The new balance of the selected token, after the operation"}},"computeInvariant(uint256[],uint8)":{"details":"This function computes the invariant based on current balances (and potentially other pool state). The rounding direction must be respected for the Vault to round in the pool's favor when calling this function. If the invariant computation involves no precision loss (e.g. simple sum of balances), the same result can be returned for both rounding directions.","params":{"balancesLiveScaled18":"Token balances after paying yield fees, applying decimal scaling and rates","rounding":"Rounding direction to consider when computing the invariant"},"returns":{"invariant":"The calculated invariant of the pool, represented as a uint256"}},"getMaximumInvariantRatio()":{"returns":{"_0":"maximumInvariantRatio The maximum invariant ratio for a pool during unbalanced add liquidity"}},"getMaximumSwapFeePercentage()":{"returns":{"_0":"maximumSwapFeePercentage The maximum swap fee percentage for a pool"}},"getMinimumInvariantRatio()":{"returns":{"_0":"minimumInvariantRatio The minimum invariant ratio for a pool during unbalanced remove liquidity"}},"getMinimumSwapFeePercentage()":{"returns":{"_0":"minimumSwapFeePercentage The minimum swap fee percentage for a pool"}},"onSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes))":{"params":{"params":"Swap parameters (see above for struct definition)"},"returns":{"amountCalculatedScaled18":"Calculated amount for the swap operation"}}},"version":1},"userdoc":{"kind":"user","methods":{"computeInvariant(uint256[],uint8)":{"notice":"Computes the pool's invariant."},"onSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes))":{"notice":"Execute a swap in the pool."}},"version":1}},"settings":{"remappings":["@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/","@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/","@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/","@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/","@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/","@openzeppelin/=lib/openzeppelin-contracts/","@test/=lib/balancer-v3-monorepo/pkg/","ds-test/=../../node_modules/forge-std/lib/ds-test/src/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","permit2/=lib/permit2/","pool-weighted/=../pool-weighted/","solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/","solidity-utils/=../solidity-utils/","vault/=../vault/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IBasePool.sol":"IBasePool"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906","urls":["bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452","dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IBasePool.sol":{"keccak256":"0xef858279c090af39f444432a75cad248c47429a0ac1dc5e93997bd4a628cc1a6","urls":["bzz-raw://c784f91edf7f34d3d827b4e93d1126546c8d4bee60a14cd80fcd219a2ae30fe5","dweb:/ipfs/QmYYFun8MYfk6HKxsrkg2LYHCPGa7ZcAZPEatmHL7C5rtC"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/ISwapFeePercentageBounds.sol":{"keccak256":"0x566aae4dcbf852199e165378977e6e49009184790e1c9cfd8cd6ddd7b9cbc3d7","urls":["bzz-raw://ce904a16c7fa36833b0e055ce8d7d15fba113b8990eab958d7f1f06faf8e7d3c","dweb:/ipfs/QmRKEQaU7sKuw93Dcj4vtxVqexvEU5m5u6aQBZE8eMKQN8"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IUnbalancedLiquidityInvariantRatioBounds.sol":{"keccak256":"0xc31c0c3cefc3c8bfb7f57a8d53b030bcee5494fe3c8fd6b2749c00e0fb8da592","urls":["bzz-raw://9a88b239a1f9af02e0d3aa60eebab8842aced2605a92be6431cdf2ed5a337ba6","dweb:/ipfs/QmdJnjg7KQQ2ieU29fuU5yjdq5BHHz59e9ts4PD2fMfVx1"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3","urls":["bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3","dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf"],"license":"GPL-3.0-or-later"},"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol":{"keccak256":"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06","urls":["bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf","dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4","urls":["bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009","dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28","urls":["bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323","dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR"],"license":"MIT"}},"version":1},"ast":{"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IBasePool.sol","id":3689,"exportedSymbols":{"IBasePool":[3688],"ISwapFeePercentageBounds":[4975],"IUnbalancedLiquidityInvariantRatioBounds":[4991],"PoolSwapParams":[6597],"Rounding":[6557],"SwapKind":[6560]},"nodeType":"SourceUnit","src":"46:3323:22","nodes":[{"id":3640,"nodeType":"PragmaDirective","src":"46:24:22","nodes":[],"literals":["solidity","^","0.8",".24"]},{"id":3642,"nodeType":"ImportDirective","src":"72:74:22","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/ISwapFeePercentageBounds.sol","file":"./ISwapFeePercentageBounds.sol","nameLocation":"-1:-1:-1","scope":3689,"sourceUnit":4976,"symbolAliases":[{"foreign":{"id":3641,"name":"ISwapFeePercentageBounds","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4975,"src":"81:24:22","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":3644,"nodeType":"ImportDirective","src":"147:106:22","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IUnbalancedLiquidityInvariantRatioBounds.sol","file":"./IUnbalancedLiquidityInvariantRatioBounds.sol","nameLocation":"-1:-1:-1","scope":3689,"sourceUnit":4992,"symbolAliases":[{"foreign":{"id":3643,"name":"IUnbalancedLiquidityInvariantRatioBounds","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4991,"src":"156:40:22","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":3648,"nodeType":"ImportDirective","src":"254:70:22","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol","file":"./VaultTypes.sol","nameLocation":"-1:-1:-1","scope":3689,"sourceUnit":6697,"symbolAliases":[{"foreign":{"id":3645,"name":"PoolSwapParams","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":6597,"src":"263:14:22","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":3646,"name":"Rounding","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":6557,"src":"279:8:22","typeDescriptions":{}},"nameLocation":"-1:-1:-1"},{"foreign":{"id":3647,"name":"SwapKind","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":6560,"src":"289:8:22","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":3688,"nodeType":"ContractDefinition","src":"710:2658:22","nodes":[{"id":3665,"nodeType":"FunctionDefinition","src":"1757:148:22","nodes":[],"documentation":{"id":3654,"nodeType":"StructuredDocumentation","src":"1014:738:22","text":" @notice Computes the pool's invariant.\n @dev This function computes the invariant based on current balances (and potentially other pool state).\n The rounding direction must be respected for the Vault to round in the pool's favor when calling this function.\n If the invariant computation involves no precision loss (e.g. simple sum of balances), the same result can be\n returned for both rounding directions.\n @param balancesLiveScaled18 Token balances after paying yield fees, applying decimal scaling and rates\n @param rounding Rounding direction to consider when computing the invariant\n @return invariant The calculated invariant of the pool, represented as a uint256"},"functionSelector":"984de9e8","implemented":false,"kind":"function","modifiers":[],"name":"computeInvariant","nameLocation":"1766:16:22","parameters":{"id":3661,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3657,"mutability":"mutable","name":"balancesLiveScaled18","nameLocation":"1809:20:22","nodeType":"VariableDeclaration","scope":3665,"src":"1792:37:22","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":3655,"name":"uint256","nodeType":"ElementaryTypeName","src":"1792:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":3656,"nodeType":"ArrayTypeName","src":"1792:9:22","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":3660,"mutability":"mutable","name":"rounding","nameLocation":"1848:8:22","nodeType":"VariableDeclaration","scope":3665,"src":"1839:17:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_enum$_Rounding_$6557","typeString":"enum Rounding"},"typeName":{"id":3659,"nodeType":"UserDefinedTypeName","pathNode":{"id":3658,"name":"Rounding","nameLocations":["1839:8:22"],"nodeType":"IdentifierPath","referencedDeclaration":6557,"src":"1839:8:22"},"referencedDeclaration":6557,"src":"1839:8:22","typeDescriptions":{"typeIdentifier":"t_enum$_Rounding_$6557","typeString":"enum Rounding"}},"visibility":"internal"}],"src":"1782:80:22"},"returnParameters":{"id":3664,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3663,"mutability":"mutable","name":"invariant","nameLocation":"1894:9:22","nodeType":"VariableDeclaration","scope":3665,"src":"1886:17:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":3662,"name":"uint256","nodeType":"ElementaryTypeName","src":"1886:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"1885:19:22"},"scope":3688,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":3678,"nodeType":"FunctionDefinition","src":"2659:182:22","nodes":[],"documentation":{"id":3666,"nodeType":"StructuredDocumentation","src":"1911:743:22","text":" @dev Computes the new balance of a token after an operation, given the invariant growth ratio and all other\n balances. Similar to V2's `_getTokenBalanceGivenInvariantAndAllOtherBalances` in StableMath.\n The pool must round up for the Vault to round in the protocol's favor when calling this function.\n @param balancesLiveScaled18 Token balances after paying yield fees, applying decimal scaling and rates\n @param tokenInIndex The index of the token we're computing the balance for, sorted in token registration order\n @param invariantRatio The ratio of the new invariant (after an operation) to the old\n @return newBalance The new balance of the selected token, after the operation"},"functionSelector":"16a0b3e0","implemented":false,"kind":"function","modifiers":[],"name":"computeBalance","nameLocation":"2668:14:22","parameters":{"id":3674,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3669,"mutability":"mutable","name":"balancesLiveScaled18","nameLocation":"2709:20:22","nodeType":"VariableDeclaration","scope":3678,"src":"2692:37:22","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":3667,"name":"uint256","nodeType":"ElementaryTypeName","src":"2692:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":3668,"nodeType":"ArrayTypeName","src":"2692:9:22","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":3671,"mutability":"mutable","name":"tokenInIndex","nameLocation":"2747:12:22","nodeType":"VariableDeclaration","scope":3678,"src":"2739:20:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":3670,"name":"uint256","nodeType":"ElementaryTypeName","src":"2739:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":3673,"mutability":"mutable","name":"invariantRatio","nameLocation":"2777:14:22","nodeType":"VariableDeclaration","scope":3678,"src":"2769:22:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":3672,"name":"uint256","nodeType":"ElementaryTypeName","src":"2769:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2682:115:22"},"returnParameters":{"id":3677,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3676,"mutability":"mutable","name":"newBalance","nameLocation":"2829:10:22","nodeType":"VariableDeclaration","scope":3678,"src":"2821:18:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":3675,"name":"uint256","nodeType":"ElementaryTypeName","src":"2821:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2820:20:22"},"scope":3688,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":3687,"nodeType":"FunctionDefinition","src":"3266:100:22","nodes":[],"documentation":{"id":3679,"nodeType":"StructuredDocumentation","src":"3055:206:22","text":" @notice Execute a swap in the pool.\n @param params Swap parameters (see above for struct definition)\n @return amountCalculatedScaled18 Calculated amount for the swap operation"},"functionSelector":"72c98186","implemented":false,"kind":"function","modifiers":[],"name":"onSwap","nameLocation":"3275:6:22","parameters":{"id":3683,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3682,"mutability":"mutable","name":"params","nameLocation":"3306:6:22","nodeType":"VariableDeclaration","scope":3687,"src":"3282:30:22","stateVariable":false,"storageLocation":"calldata","typeDescriptions":{"typeIdentifier":"t_struct$_PoolSwapParams_$6597_calldata_ptr","typeString":"struct PoolSwapParams"},"typeName":{"id":3681,"nodeType":"UserDefinedTypeName","pathNode":{"id":3680,"name":"PoolSwapParams","nameLocations":["3282:14:22"],"nodeType":"IdentifierPath","referencedDeclaration":6597,"src":"3282:14:22"},"referencedDeclaration":6597,"src":"3282:14:22","typeDescriptions":{"typeIdentifier":"t_struct$_PoolSwapParams_$6597_storage_ptr","typeString":"struct PoolSwapParams"}},"visibility":"internal"}],"src":"3281:32:22"},"returnParameters":{"id":3686,"nodeType":"ParameterList","parameters":[{"constant":false,"id":3685,"mutability":"mutable","name":"amountCalculatedScaled18","nameLocation":"3340:24:22","nodeType":"VariableDeclaration","scope":3687,"src":"3332:32:22","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":3684,"name":"uint256","nodeType":"ElementaryTypeName","src":"3332:7:22","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3331:34:22"},"scope":3688,"stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[{"baseName":{"id":3650,"name":"ISwapFeePercentageBounds","nameLocations":["733:24:22"],"nodeType":"IdentifierPath","referencedDeclaration":4975,"src":"733:24:22"},"id":3651,"nodeType":"InheritanceSpecifier","src":"733:24:22"},{"baseName":{"id":3652,"name":"IUnbalancedLiquidityInvariantRatioBounds","nameLocations":["759:40:22"],"nodeType":"IdentifierPath","referencedDeclaration":4991,"src":"759:40:22"},"id":3653,"nodeType":"InheritanceSpecifier","src":"759:40:22"}],"canonicalName":"IBasePool","contractDependencies":[],"contractKind":"interface","documentation":{"id":3649,"nodeType":"StructuredDocumentation","src":"326:383:22","text":" @notice Base interface for a Balancer Pool.\n @dev All pool types should implement this interface. Note that it also requires implementation of:\n - `ISwapFeePercentageBounds` to specify the minimum and maximum swap fee percentages.\n - `IUnbalancedLiquidityInvariantRatioBounds` to specify how much the invariant can change during an unbalanced\n liquidity operation."},"fullyImplemented":false,"linearizedBaseContracts":[3688,4991,4975],"name":"IBasePool","nameLocation":"720:9:22","scope":3689,"usedErrors":[],"usedEvents":[]}],"license":"GPL-3.0-or-later"},"id":22}