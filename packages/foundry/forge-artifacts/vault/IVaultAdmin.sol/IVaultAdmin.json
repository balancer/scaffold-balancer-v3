{"abi":[{"type":"function","name":"addLiquidityToBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"exactSharesToIssue","type":"uint256","internalType":"uint256"},{"name":"sharesOwner","type":"address","internalType":"address"}],"outputs":[{"name":"amountUnderlyingRaw","type":"uint256","internalType":"uint256"},{"name":"amountWrappedRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"areBuffersPaused","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"collectAggregateFees","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[{"name":"swapFeeAmounts","type":"uint256[]","internalType":"uint256[]"},{"name":"yieldFeeAmounts","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"nonpayable"},{"type":"function","name":"disableQuery","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"disableRecoveryMode","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"enableRecoveryMode","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBufferAsset","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"underlyingToken","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"getBufferBalance","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"underlyingBalanceRaw","type":"uint256","internalType":"uint256"},{"name":"wrappedBalanceRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getBufferMinimumTotalSupply","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getBufferOwnerShares","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"liquidityOwner","type":"address","internalType":"address"}],"outputs":[{"name":"ownerShares","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getBufferPeriodDuration","inputs":[],"outputs":[{"name":"","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getBufferPeriodEndTime","inputs":[],"outputs":[{"name":"","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getBufferTotalShares","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"}],"outputs":[{"name":"bufferShares","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMaximumPoolTokens","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getMinimumPoolTokens","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getMinimumTradeAmount","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getMinimumWrapAmount","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"getPauseWindowEndTime","inputs":[],"outputs":[{"name":"","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"getPoolMinimumTotalSupply","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"pure"},{"type":"function","name":"getVaultPausedState","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"},{"name":"","type":"uint32","internalType":"uint32"},{"name":"","type":"uint32","internalType":"uint32"}],"stateMutability":"view"},{"type":"function","name":"initializeBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"amountUnderlyingRaw","type":"uint256","internalType":"uint256"},{"name":"amountWrappedRaw","type":"uint256","internalType":"uint256"},{"name":"sharesOwner","type":"address","internalType":"address"}],"outputs":[{"name":"issuedShares","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"isVaultPaused","inputs":[],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"pausePool","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"pauseVault","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"pauseVaultBuffers","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"removeLiquidityFromBuffer","inputs":[{"name":"wrappedToken","type":"address","internalType":"contract IERC4626"},{"name":"sharesToRemove","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"removedUnderlyingBalanceRaw","type":"uint256","internalType":"uint256"},{"name":"removedWrappedBalanceRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"setAuthorizer","inputs":[{"name":"newAuthorizer","type":"address","internalType":"contract IAuthorizer"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setProtocolFeeController","inputs":[{"name":"newProtocolFeeController","type":"address","internalType":"contract IProtocolFeeController"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setStaticSwapFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"swapFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpausePool","inputs":[{"name":"pool","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpauseVault","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unpauseVaultBuffers","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateAggregateSwapFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"newAggregateSwapFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"updateAggregateYieldFeePercentage","inputs":[{"name":"pool","type":"address","internalType":"address"},{"name":"newAggregateYieldFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"vault","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IVault"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"addLiquidityToBuffer(address,uint256,address)":"d446e4a6","areBuffersPaused()":"55cba7fe","collectAggregateFees(address)":"8f4ab9ca","disableQuery()":"de1a36a6","disableRecoveryMode(address)":"bffb78b2","enableRecoveryMode(address)":"dc3f574e","getBufferAsset(address)":"0387587d","getBufferBalance(address)":"4021fe0f","getBufferMinimumTotalSupply()":"26a8a991","getBufferOwnerShares(address,address)":"9385e39a","getBufferPeriodDuration()":"20c1fb7a","getBufferPeriodEndTime()":"cd51c12f","getBufferTotalShares(address)":"f2784e07","getMaximumPoolTokens()":"2e42f4d5","getMinimumPoolTokens()":"a8175b27","getMinimumTradeAmount()":"e2cb0ba0","getMinimumWrapAmount()":"53956aa2","getPauseWindowEndTime()":"8a8d123a","getPoolMinimumTotalSupply()":"d0965a6b","getVaultPausedState()":"85c8c015","initializeBuffer(address,uint256,uint256,address)":"40058e35","isVaultPaused()":"098401f5","pausePool(address)":"55aca1ec","pauseVault()":"9e0879c2","pauseVaultBuffers()":"e085c5a8","removeLiquidityFromBuffer(address,uint256)":"35b60a19","setAuthorizer(address)":"058a628f","setProtocolFeeController(address)":"2d771389","setStaticSwapFeePercentage(address,uint256)":"d15126ba","unpausePool(address)":"f21c38cd","unpauseVault()":"0b7562be","unpauseVaultBuffers()":"b9212b49","updateAggregateSwapFeePercentage(address,uint256)":"5e0b06f4","updateAggregateYieldFeePercentage(address,uint256)":"e253670a","vault()":"fbfa77cf"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exactSharesToIssue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sharesOwner\",\"type\":\"address\"}],\"name\":\"addLiquidityToBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUnderlyingRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWrappedRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"areBuffersPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"collectAggregateFees\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"swapFeeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldFeeAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableQuery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"disableRecoveryMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"enableRecoveryMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingBalanceRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wrappedBalanceRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferMinimumTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityOwner\",\"type\":\"address\"}],\"name\":\"getBufferOwnerShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ownerShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferPeriodDuration\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBufferPeriodEndTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"}],\"name\":\"getBufferTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bufferShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumTradeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumWrapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPauseWindowEndTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolMinimumTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultPausedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountUnderlyingRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountWrappedRaw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sharesOwner\",\"type\":\"address\"}],\"name\":\"initializeBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"issuedShares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVaultPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"pausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseVaultBuffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC4626\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesToRemove\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityFromBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"removedUnderlyingBalanceRaw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"removedWrappedBalanceRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAuthorizer\",\"name\":\"newAuthorizer\",\"type\":\"address\"}],\"name\":\"setAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IProtocolFeeController\",\"name\":\"newProtocolFeeController\",\"type\":\"address\"}],\"name\":\"setProtocolFeeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"swapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setStaticSwapFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"unpausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseVaultBuffers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAggregateSwapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updateAggregateSwapFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAggregateYieldFeePercentage\",\"type\":\"uint256\"}],\"name\":\"updateAggregateYieldFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"`VaultAdmin` is the Proxy extension of `VaultExtension`, and handles the least critical operations, as two delegate calls add gas to each call. Most of the permissioned calls are here.\",\"kind\":\"dev\",\"methods\":{\"addLiquidityToBuffer(address,uint256,address)\":{\"details\":\"The buffer needs to be initialized beforehand.\",\"params\":{\"exactSharesToIssue\":\"The value in underlying tokens that `sharesOwner` wants to add to the buffer, in underlying token decimals\",\"sharesOwner\":\"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"amountUnderlyingRaw\":\"Amount of underlying tokens deposited into the buffer\",\"amountWrappedRaw\":\"Amount of wrapped tokens deposited into the buffer\"}},\"areBuffersPaused()\":{\"details\":\"When buffers are paused, all buffer operations (i.e., calls on the Router with `isBuffer` true) will revert. Pausing buffers is reversible.\",\"returns\":{\"_0\":\"buffersPaused True if the Vault buffers are paused\"}},\"collectAggregateFees(address)\":{\"details\":\"Fees are sent to the ProtocolFeeController address.\",\"params\":{\"pool\":\"The pool on which all aggregate fees should be collected\"},\"returns\":{\"swapFeeAmounts\":\"An array with the total swap fees collected, sorted in token registration order\",\"yieldFeeAmounts\":\"An array with the total yield fees collected, sorted in token registration order\"}},\"disableRecoveryMode(address)\":{\"details\":\"This is a permissioned function. It re-syncs live balances (which could not be updated during Recovery Mode), forfeiting any yield fees that accrued while enabled. It makes external calls, and could potentially fail if there is an issue with any associated Rate Providers.\",\"params\":{\"pool\":\"The address of the pool\"}},\"enableRecoveryMode(address)\":{\"details\":\"This is a permissioned function. It enables a safe proportional withdrawal, with no external calls. Since there are no external calls, live balances cannot be updated while in Recovery Mode.\",\"params\":{\"pool\":\"The address of the pool\"}},\"getBufferAsset(address)\":{\"details\":\"The asset can never change after buffer initialization.\",\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"underlyingToken\":\"Address of the underlying token registered for the wrapper; `address(0)` if the buffer has not been initialized.\"}},\"getBufferBalance(address)\":{\"details\":\"All values are in native token decimals of the wrapped or underlying tokens.\",\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"underlyingBalanceRaw\":\"Amount of underlying tokens deposited into the buffer, in native token decimals\",\"wrappedBalanceRaw\":\"Amount of wrapped tokens deposited into the buffer, in native token decimals\"}},\"getBufferMinimumTotalSupply()\":{\"details\":\"This prevents buffers from being completely drained. When the buffer is initialized, this minimum number of shares is added to the shares resulting from the initial deposit. Buffer total supply accounting is internal to the Vault, as buffers are not tokenized.\",\"returns\":{\"_0\":\"minimumTotalSupply The minimum total supply a buffer can have after initialization\"}},\"getBufferOwnerShares(address,address)\":{\"params\":{\"liquidityOwner\":\"Address of the user that owns liquidity in the wrapped token's buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"ownerShares\":\"Amount of shares allocated to the liquidity owner, in native underlying token decimals\"}},\"getBufferPeriodDuration()\":{\"details\":\"This value is immutable. It represents the period during which, if paused, the Vault will remain paused. This ensures there is time available to address whatever issue caused the Vault to be paused.\",\"returns\":{\"_0\":\"bufferPeriodDuration The length of the buffer period in seconds\"}},\"getBufferPeriodEndTime()\":{\"details\":\"This value is immutable. If already paused, the Vault can be unpaused until this timestamp.\",\"returns\":{\"_0\":\"bufferPeriodEndTime The timestamp after which the Vault remains permanently unpaused\"}},\"getBufferTotalShares(address)\":{\"params\":{\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"bufferShares\":\"Amount of supply shares of the buffer, in native underlying token decimals\"}},\"getMaximumPoolTokens()\":{\"returns\":{\"_0\":\"maxTokens The maximum token count of a pool\"}},\"getMinimumPoolTokens()\":{\"details\":\"We expect the vast majority of pools to be 2-token.\",\"returns\":{\"_0\":\"minTokens The minimum token count of a pool\"}},\"getMinimumTradeAmount()\":{\"details\":\"This limit is applied to the 18-decimal \\\"upscaled\\\" amount in any operation (swap, add/remove liquidity).\",\"returns\":{\"_0\":\"minimumTradeAmount The minimum trade amount as an 18-decimal floating point number\"}},\"getMinimumWrapAmount()\":{\"details\":\"This limit is applied to the wrap operation amount, in native underlying token decimals.\",\"returns\":{\"_0\":\"minimumWrapAmount The minimum wrap amount in native underlying token decimals\"}},\"getPauseWindowEndTime()\":{\"details\":\"This value is immutable, and represents the timestamp after which the Vault can no longer be paused by governance.\",\"returns\":{\"_0\":\"pauseWindowEndTime The timestamp when the Vault's pause window ends\"}},\"getPoolMinimumTotalSupply()\":{\"details\":\"This prevents pools from being completely drained. When the pool is initialized, this minimum amount of BPT is minted to the zero address. This is an 18-decimal floating point number; BPT are always 18 decimals.\",\"returns\":{\"_0\":\"minimumTotalSupply The minimum total supply a pool can have after initialization\"}},\"getVaultPausedState()\":{\"returns\":{\"_0\":\"paused True if the Vault is paused\",\"_1\":\"vaultPauseWindowEndTime The timestamp of the end of the Vault's pause window\",\"_2\":\"vaultBufferPeriodEndTime The timestamp of the end of the Vault's buffer period\"}},\"initializeBuffer(address,uint256,uint256,address)\":{\"params\":{\"amountUnderlyingRaw\":\"Amount of underlying tokens that will be deposited into the buffer\",\"amountWrappedRaw\":\"Amount of wrapped tokens that will be deposited into the buffer\",\"sharesOwner\":\"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"issuedShares\":\"the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts. (it is the BPT of an internal ERC4626 buffer). It is expressed in underlying token native decimals.\"}},\"isVaultPaused()\":{\"details\":\"If the Vault is paused, all non-Recovery Mode state-changing operations will revert.\",\"returns\":{\"_0\":\"paused True if the Vault is paused\"}},\"pausePool(address)\":{\"details\":\"This is a permissioned function that will only work during the Pause Window set during pool factory deployment.\",\"params\":{\"pool\":\"The pool being paused\"}},\"pauseVault()\":{\"details\":\"This is a permissioned function that will only work during the Pause Window set during deployment.\"},\"pauseVaultBuffers()\":{\"details\":\"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. Currently it's not possible to pause vault buffers individually. This is a permissioned call, and is reversible (see `unpauseVaultBuffers`).\"},\"removeLiquidityFromBuffer(address,uint256)\":{\"details\":\"Only proportional exits are supported, and the sender has to be the owner of the shares. This function unlocks the Vault just for this operation; it does not work with a Router as an entrypoint. Pre-conditions: - The buffer needs to be initialized. - sharesOwner is the original msg.sender, it needs to be checked in the Router. That's why   this call is authenticated; only routers approved by the DAO can remove the liquidity of a buffer. - The buffer needs to have some liquidity and have its asset registered in `_bufferAssets` storage.\",\"params\":{\"sharesToRemove\":\"Amount of shares to remove from the buffer. Cannot be greater than sharesOwner's total shares. It is expressed in underlying token native decimals.\",\"wrappedToken\":\"Address of the wrapped token that implements IERC4626\"},\"returns\":{\"removedUnderlyingBalanceRaw\":\"Amount of underlying tokens returned to the user\",\"removedWrappedBalanceRaw\":\"Amount of wrapped tokens returned to the user\"}},\"setAuthorizer(address)\":{\"details\":\"This is a permissioned call. Emits an `AuthorizerChanged` event.\",\"params\":{\"newAuthorizer\":\"The address of the new authorizer\"}},\"setProtocolFeeController(address)\":{\"details\":\"This is a permissioned call. Emits a `ProtocolFeeControllerChanged` event.\",\"params\":{\"newProtocolFeeController\":\"The address of the new Protocol Fee Controller\"}},\"setStaticSwapFeePercentage(address,uint256)\":{\"details\":\"This is a permissioned function, disabled if the pool is paused. The swap fee percentage must be within the bounds specified by the pool's implementation of `ISwapFeePercentageBounds`. Emits the SwapFeePercentageChanged event.\",\"params\":{\"pool\":\"The address of the pool for which the static swap fee will be changed\",\"swapFeePercentage\":\"The new swap fee percentage to apply to the pool\"}},\"unpausePool(address)\":{\"details\":\"This is a permissioned function that will only work on a paused Pool within the Buffer Period set during deployment. Note that the Pool will automatically unpause after the Buffer Period expires.\",\"params\":{\"pool\":\"The pool being unpaused\"}},\"unpauseVault()\":{\"details\":\"This is a permissioned function that will only work on a paused Vault within the Buffer Period set during deployment. Note that the Vault will automatically unpause after the Buffer Period expires.\"},\"unpauseVaultBuffers()\":{\"details\":\"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. This is a permissioned call.\"},\"updateAggregateSwapFeePercentage(address,uint256)\":{\"details\":\"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateSwapFeePercentageChanged` event.\",\"params\":{\"newAggregateSwapFeePercentage\":\"The new aggregate swap fee percentage\",\"pool\":\"The pool whose fee will be updated\"}},\"updateAggregateYieldFeePercentage(address,uint256)\":{\"details\":\"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateYieldFeePercentageChanged` event.\",\"params\":{\"newAggregateYieldFeePercentage\":\"The new aggregate yield fee percentage\",\"pool\":\"The pool whose fee will be updated\"}},\"vault()\":{\"details\":\"The main Vault contains the entrypoint and main liquidity operation implementations.\",\"returns\":{\"_0\":\"vault The address of the main Vault\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addLiquidityToBuffer(address,uint256,address)\":{\"notice\":\"Adds liquidity to an internal ERC4626 buffer in the Vault, proportionally.\"},\"areBuffersPaused()\":{\"notice\":\"Indicates whether the Vault buffers are paused.\"},\"collectAggregateFees(address)\":{\"notice\":\"Collects accumulated aggregate swap and yield fees for the specified pool.\"},\"disableQuery()\":{\"notice\":\"Disables queries functionality on the Vault. Can only be called by governance.\"},\"disableRecoveryMode(address)\":{\"notice\":\"Disable recovery mode for a pool.\"},\"enableRecoveryMode(address)\":{\"notice\":\"Enable recovery mode for a pool.\"},\"getBufferAsset(address)\":{\"notice\":\"Returns the asset registered for a given wrapped token.\"},\"getBufferBalance(address)\":{\"notice\":\"Returns the amount of underlying and wrapped tokens deposited in the internal buffer of the Vault.\"},\"getBufferMinimumTotalSupply()\":{\"notice\":\"Get the minimum total supply of an ERC4626 wrapped token buffer in the Vault.\"},\"getBufferOwnerShares(address,address)\":{\"notice\":\"Returns the shares (internal buffer BPT) of a liquidity owner: a user that deposited assets in the buffer.\"},\"getBufferPeriodDuration()\":{\"notice\":\"Returns the Vault's buffer period duration.\"},\"getBufferPeriodEndTime()\":{\"notice\":\"Returns the Vault's buffer period end time.\"},\"getBufferTotalShares(address)\":{\"notice\":\"Returns the supply shares (internal buffer BPT) of the ERC4626 buffer.\"},\"getMaximumPoolTokens()\":{\"notice\":\"Get the maximum number of tokens in a pool.\"},\"getMinimumPoolTokens()\":{\"notice\":\"Get the minimum number of tokens in a pool.\"},\"getMinimumTradeAmount()\":{\"notice\":\"Get the minimum trade amount in a pool operation.\"},\"getMinimumWrapAmount()\":{\"notice\":\"Get the minimum wrap amount in a buffer operation.\"},\"getPauseWindowEndTime()\":{\"notice\":\"Returns the Vault's pause window end time.\"},\"getPoolMinimumTotalSupply()\":{\"notice\":\"Get the minimum total supply of pool tokens (BPT) for an initialized pool.\"},\"getVaultPausedState()\":{\"notice\":\"Returns the paused status, and end times of the Vault's pause window and buffer period.\"},\"initializeBuffer(address,uint256,uint256,address)\":{\"notice\":\"Initializes buffer for the given wrapped token.\"},\"isVaultPaused()\":{\"notice\":\"Indicates whether the Vault is paused.\"},\"pausePool(address)\":{\"notice\":\"Pause the Pool: an emergency action which disables all pool functions.\"},\"pauseVault()\":{\"notice\":\"Pause the Vault: an emergency action which disables all operational state-changing functions.\"},\"pauseVaultBuffers()\":{\"notice\":\"Pauses native vault buffers globally.\"},\"removeLiquidityFromBuffer(address,uint256)\":{\"notice\":\"Removes liquidity from an internal ERC4626 buffer in the Vault.\"},\"setAuthorizer(address)\":{\"notice\":\"Sets a new Authorizer for the Vault.\"},\"setProtocolFeeController(address)\":{\"notice\":\"Sets a new Protocol Fee Controller for the Vault.\"},\"setStaticSwapFeePercentage(address,uint256)\":{\"notice\":\"Assigns a new static swap fee percentage to the specified pool.\"},\"unpausePool(address)\":{\"notice\":\"Reverse a `pause` operation, and restore the Pool to normal functionality.\"},\"unpauseVault()\":{\"notice\":\"Reverse a `pause` operation, and restore the Vault to normal functionality.\"},\"unpauseVaultBuffers()\":{\"notice\":\"Unpauses native vault buffers globally.\"},\"updateAggregateSwapFeePercentage(address,uint256)\":{\"notice\":\"Update an aggregate swap fee percentage.\"},\"updateAggregateYieldFeePercentage(address,uint256)\":{\"notice\":\"Update an aggregate yield fee percentage.\"},\"vault()\":{\"notice\":\"Returns the main Vault address.\"}},\"notice\":\"Interface for functions defined on the `VaultAdmin` contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol\":\"IVaultAdmin\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":999},\"remappings\":[\":@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/\",\":@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/\",\":@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/\",\":@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/\",\":@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@test/=lib/balancer-v3-monorepo/pkg/\",\":ds-test/=../../node_modules/forge-std/lib/ds-test/src/\",\":forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":permit2/=lib/permit2/\",\":pool-weighted/=../pool-weighted/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\":solidity-utils/=../solidity-utils/\",\":vault/=../vault/\"]},\"sources\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IAuthentication.sol\":{\"keccak256\":\"0x3c4c0cf4d69eec7f6ad108391607be00f1f7ef9867eb7ba03738d61d052c2ed2\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://023b1414a8ef990cfcc3af005f540c70539b0107feb2103d0c2f70ccdad41a87\",\"dweb:/ipfs/QmdJuumhraGU5Vjs9QZDATSV4VXEoPdmH6nuM7aNxgmRQo\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452\",\"dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol\":{\"keccak256\":\"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c\",\"dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol\":{\"keccak256\":\"0x90f77758dbdfdb952754aa3fbfbdf816afb9592b49a12932cf6636bb6dab6638\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://bf3a76192ee4290f81c33dcc28889761087b0f3f5324bdf0c5487504a349df5f\",\"dweb:/ipfs/QmX5tH5yox4riErpQ43BEmc7L11C65ob53gRQ5VUBdNM3Y\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IProtocolFeeController.sol\":{\"keccak256\":\"0x265cba6f0225fae5867e47ead3b7d51ea124c6599d450b361bb86795ffb0a586\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://9363b61e7b592c6d9476cfcdc9d468669f3e9d2d232ad426f6c5c6c00247258e\",\"dweb:/ipfs/QmT771Kpp4VswEcBCJCMxKKKiRNMcLJeziKCisjLrc2opx\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVault.sol\":{\"keccak256\":\"0xdc75f953e7fcb8dee0f26935ce638cfb515f512719bfe5c57e117f366b2cbb7c\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://4ec167998306d37a2c4e2ab76cee77d252e5f868019f3a038241227c7a06e566\",\"dweb:/ipfs/QmQfB1yvkSrcZpTThv3TuuT7zvKfU1euVAf1av2hPuj9GH\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol\":{\"keccak256\":\"0xe68fbe2bef8c4fda8cf43d186d0e5518f9d76e57ac1c2f8082a1d0bcf444ace7\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://614fb11ff5f7ea15cab882dfe4c7f69656eb5ad0e7cb217338664d8f1d0403c7\",\"dweb:/ipfs/QmUPZRXKFLsGEiPM38uDz14EVvJV81NCNBoWajmAbEmDka\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultErrors.sol\":{\"keccak256\":\"0x3bf1cfa4716401af08fd265db6ebbaad011d94d4531be5a6289aafbe4dc02f0f\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://7969b076f81af1fec02a0cc572ea56be691315bbcc761bb47e38aecb86ae15fc\",\"dweb:/ipfs/QmPkYWjEEj9Kzrbhcc6i8mmB1WAopcf13Ue2ZhayTXtnBm\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultEvents.sol\":{\"keccak256\":\"0xfa87a090e0b1fc87e34b6a891b7abd4697e75997e37d073020b91c7c408bffe3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://2b33f211008d57462d8b4598b78e477ce6ee53f0c1172682b94e896954752fe9\",\"dweb:/ipfs/QmVzjPRey6qss4ucJx3Mb1gs5MAyLKcLUD5tLt9KNn2SNR\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultExtension.sol\":{\"keccak256\":\"0x2c6f4f4d714a0f1e7e648909753839da8182117f22018f4337f9632f9c40597b\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://99fb94d7fcf9f972f4aec716d7d4be43e3d28f90f8f5923b9b8245be178e01aa\",\"dweb:/ipfs/QmeLSFfcvYwmPpQ58yESVjYXPY13NzGU28WjxkWUj8sgqx\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol\":{\"keccak256\":\"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6\",\"dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3\",\"dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf\",\"dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323\",\"dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"exactSharesToIssue","type":"uint256"},{"internalType":"address","name":"sharesOwner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"addLiquidityToBuffer","outputs":[{"internalType":"uint256","name":"amountUnderlyingRaw","type":"uint256"},{"internalType":"uint256","name":"amountWrappedRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"areBuffersPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"collectAggregateFees","outputs":[{"internalType":"uint256[]","name":"swapFeeAmounts","type":"uint256[]"},{"internalType":"uint256[]","name":"yieldFeeAmounts","type":"uint256[]"}]},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"disableQuery"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"disableRecoveryMode"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"enableRecoveryMode"},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferAsset","outputs":[{"internalType":"address","name":"underlyingToken","type":"address"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferBalance","outputs":[{"internalType":"uint256","name":"underlyingBalanceRaw","type":"uint256"},{"internalType":"uint256","name":"wrappedBalanceRaw","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getBufferMinimumTotalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"address","name":"liquidityOwner","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferOwnerShares","outputs":[{"internalType":"uint256","name":"ownerShares","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getBufferPeriodDuration","outputs":[{"internalType":"uint32","name":"","type":"uint32"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getBufferPeriodEndTime","outputs":[{"internalType":"uint32","name":"","type":"uint32"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"}],"stateMutability":"view","type":"function","name":"getBufferTotalShares","outputs":[{"internalType":"uint256","name":"bufferShares","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getMaximumPoolTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getMinimumPoolTokens","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumTradeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getMinimumWrapAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getPauseWindowEndTime","outputs":[{"internalType":"uint32","name":"","type":"uint32"}]},{"inputs":[],"stateMutability":"pure","type":"function","name":"getPoolMinimumTotalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"getVaultPausedState","outputs":[{"internalType":"bool","name":"","type":"bool"},{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"uint32","name":"","type":"uint32"}]},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"amountUnderlyingRaw","type":"uint256"},{"internalType":"uint256","name":"amountWrappedRaw","type":"uint256"},{"internalType":"address","name":"sharesOwner","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"initializeBuffer","outputs":[{"internalType":"uint256","name":"issuedShares","type":"uint256"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"isVaultPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"pausePool"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"pauseVault"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"pauseVaultBuffers"},{"inputs":[{"internalType":"contract IERC4626","name":"wrappedToken","type":"address"},{"internalType":"uint256","name":"sharesToRemove","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"removeLiquidityFromBuffer","outputs":[{"internalType":"uint256","name":"removedUnderlyingBalanceRaw","type":"uint256"},{"internalType":"uint256","name":"removedWrappedBalanceRaw","type":"uint256"}]},{"inputs":[{"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setAuthorizer"},{"inputs":[{"internalType":"contract IProtocolFeeController","name":"newProtocolFeeController","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"setProtocolFeeController"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"swapFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"setStaticSwapFeePercentage"},{"inputs":[{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"unpausePool"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"unpauseVault"},{"inputs":[],"stateMutability":"nonpayable","type":"function","name":"unpauseVaultBuffers"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"newAggregateSwapFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"updateAggregateSwapFeePercentage"},{"inputs":[{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"newAggregateYieldFeePercentage","type":"uint256"}],"stateMutability":"nonpayable","type":"function","name":"updateAggregateYieldFeePercentage"},{"inputs":[],"stateMutability":"view","type":"function","name":"vault","outputs":[{"internalType":"contract IVault","name":"","type":"address"}]}],"devdoc":{"kind":"dev","methods":{"addLiquidityToBuffer(address,uint256,address)":{"details":"The buffer needs to be initialized beforehand.","params":{"exactSharesToIssue":"The value in underlying tokens that `sharesOwner` wants to add to the buffer, in underlying token decimals","sharesOwner":"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"amountUnderlyingRaw":"Amount of underlying tokens deposited into the buffer","amountWrappedRaw":"Amount of wrapped tokens deposited into the buffer"}},"areBuffersPaused()":{"details":"When buffers are paused, all buffer operations (i.e., calls on the Router with `isBuffer` true) will revert. Pausing buffers is reversible.","returns":{"_0":"buffersPaused True if the Vault buffers are paused"}},"collectAggregateFees(address)":{"details":"Fees are sent to the ProtocolFeeController address.","params":{"pool":"The pool on which all aggregate fees should be collected"},"returns":{"swapFeeAmounts":"An array with the total swap fees collected, sorted in token registration order","yieldFeeAmounts":"An array with the total yield fees collected, sorted in token registration order"}},"disableRecoveryMode(address)":{"details":"This is a permissioned function. It re-syncs live balances (which could not be updated during Recovery Mode), forfeiting any yield fees that accrued while enabled. It makes external calls, and could potentially fail if there is an issue with any associated Rate Providers.","params":{"pool":"The address of the pool"}},"enableRecoveryMode(address)":{"details":"This is a permissioned function. It enables a safe proportional withdrawal, with no external calls. Since there are no external calls, live balances cannot be updated while in Recovery Mode.","params":{"pool":"The address of the pool"}},"getBufferAsset(address)":{"details":"The asset can never change after buffer initialization.","params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"underlyingToken":"Address of the underlying token registered for the wrapper; `address(0)` if the buffer has not been initialized."}},"getBufferBalance(address)":{"details":"All values are in native token decimals of the wrapped or underlying tokens.","params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"underlyingBalanceRaw":"Amount of underlying tokens deposited into the buffer, in native token decimals","wrappedBalanceRaw":"Amount of wrapped tokens deposited into the buffer, in native token decimals"}},"getBufferMinimumTotalSupply()":{"details":"This prevents buffers from being completely drained. When the buffer is initialized, this minimum number of shares is added to the shares resulting from the initial deposit. Buffer total supply accounting is internal to the Vault, as buffers are not tokenized.","returns":{"_0":"minimumTotalSupply The minimum total supply a buffer can have after initialization"}},"getBufferOwnerShares(address,address)":{"params":{"liquidityOwner":"Address of the user that owns liquidity in the wrapped token's buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"ownerShares":"Amount of shares allocated to the liquidity owner, in native underlying token decimals"}},"getBufferPeriodDuration()":{"details":"This value is immutable. It represents the period during which, if paused, the Vault will remain paused. This ensures there is time available to address whatever issue caused the Vault to be paused.","returns":{"_0":"bufferPeriodDuration The length of the buffer period in seconds"}},"getBufferPeriodEndTime()":{"details":"This value is immutable. If already paused, the Vault can be unpaused until this timestamp.","returns":{"_0":"bufferPeriodEndTime The timestamp after which the Vault remains permanently unpaused"}},"getBufferTotalShares(address)":{"params":{"wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"bufferShares":"Amount of supply shares of the buffer, in native underlying token decimals"}},"getMaximumPoolTokens()":{"returns":{"_0":"maxTokens The maximum token count of a pool"}},"getMinimumPoolTokens()":{"details":"We expect the vast majority of pools to be 2-token.","returns":{"_0":"minTokens The minimum token count of a pool"}},"getMinimumTradeAmount()":{"details":"This limit is applied to the 18-decimal \"upscaled\" amount in any operation (swap, add/remove liquidity).","returns":{"_0":"minimumTradeAmount The minimum trade amount as an 18-decimal floating point number"}},"getMinimumWrapAmount()":{"details":"This limit is applied to the wrap operation amount, in native underlying token decimals.","returns":{"_0":"minimumWrapAmount The minimum wrap amount in native underlying token decimals"}},"getPauseWindowEndTime()":{"details":"This value is immutable, and represents the timestamp after which the Vault can no longer be paused by governance.","returns":{"_0":"pauseWindowEndTime The timestamp when the Vault's pause window ends"}},"getPoolMinimumTotalSupply()":{"details":"This prevents pools from being completely drained. When the pool is initialized, this minimum amount of BPT is minted to the zero address. This is an 18-decimal floating point number; BPT are always 18 decimals.","returns":{"_0":"minimumTotalSupply The minimum total supply a pool can have after initialization"}},"getVaultPausedState()":{"returns":{"_0":"paused True if the Vault is paused","_1":"vaultPauseWindowEndTime The timestamp of the end of the Vault's pause window","_2":"vaultBufferPeriodEndTime The timestamp of the end of the Vault's buffer period"}},"initializeBuffer(address,uint256,uint256,address)":{"params":{"amountUnderlyingRaw":"Amount of underlying tokens that will be deposited into the buffer","amountWrappedRaw":"Amount of wrapped tokens that will be deposited into the buffer","sharesOwner":"Address that will own the deposited liquidity. Only this address will be able to remove liquidity from the buffer","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"issuedShares":"the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts. (it is the BPT of an internal ERC4626 buffer). It is expressed in underlying token native decimals."}},"isVaultPaused()":{"details":"If the Vault is paused, all non-Recovery Mode state-changing operations will revert.","returns":{"_0":"paused True if the Vault is paused"}},"pausePool(address)":{"details":"This is a permissioned function that will only work during the Pause Window set during pool factory deployment.","params":{"pool":"The pool being paused"}},"pauseVault()":{"details":"This is a permissioned function that will only work during the Pause Window set during deployment."},"pauseVaultBuffers()":{"details":"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. Currently it's not possible to pause vault buffers individually. This is a permissioned call, and is reversible (see `unpauseVaultBuffers`)."},"removeLiquidityFromBuffer(address,uint256)":{"details":"Only proportional exits are supported, and the sender has to be the owner of the shares. This function unlocks the Vault just for this operation; it does not work with a Router as an entrypoint. Pre-conditions: - The buffer needs to be initialized. - sharesOwner is the original msg.sender, it needs to be checked in the Router. That's why   this call is authenticated; only routers approved by the DAO can remove the liquidity of a buffer. - The buffer needs to have some liquidity and have its asset registered in `_bufferAssets` storage.","params":{"sharesToRemove":"Amount of shares to remove from the buffer. Cannot be greater than sharesOwner's total shares. It is expressed in underlying token native decimals.","wrappedToken":"Address of the wrapped token that implements IERC4626"},"returns":{"removedUnderlyingBalanceRaw":"Amount of underlying tokens returned to the user","removedWrappedBalanceRaw":"Amount of wrapped tokens returned to the user"}},"setAuthorizer(address)":{"details":"This is a permissioned call. Emits an `AuthorizerChanged` event.","params":{"newAuthorizer":"The address of the new authorizer"}},"setProtocolFeeController(address)":{"details":"This is a permissioned call. Emits a `ProtocolFeeControllerChanged` event.","params":{"newProtocolFeeController":"The address of the new Protocol Fee Controller"}},"setStaticSwapFeePercentage(address,uint256)":{"details":"This is a permissioned function, disabled if the pool is paused. The swap fee percentage must be within the bounds specified by the pool's implementation of `ISwapFeePercentageBounds`. Emits the SwapFeePercentageChanged event.","params":{"pool":"The address of the pool for which the static swap fee will be changed","swapFeePercentage":"The new swap fee percentage to apply to the pool"}},"unpausePool(address)":{"details":"This is a permissioned function that will only work on a paused Pool within the Buffer Period set during deployment. Note that the Pool will automatically unpause after the Buffer Period expires.","params":{"pool":"The pool being unpaused"}},"unpauseVault()":{"details":"This is a permissioned function that will only work on a paused Vault within the Buffer Period set during deployment. Note that the Vault will automatically unpause after the Buffer Period expires."},"unpauseVaultBuffers()":{"details":"When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. This is a permissioned call."},"updateAggregateSwapFeePercentage(address,uint256)":{"details":"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateSwapFeePercentageChanged` event.","params":{"newAggregateSwapFeePercentage":"The new aggregate swap fee percentage","pool":"The pool whose fee will be updated"}},"updateAggregateYieldFeePercentage(address,uint256)":{"details":"Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol). Emits an `AggregateYieldFeePercentageChanged` event.","params":{"newAggregateYieldFeePercentage":"The new aggregate yield fee percentage","pool":"The pool whose fee will be updated"}},"vault()":{"details":"The main Vault contains the entrypoint and main liquidity operation implementations.","returns":{"_0":"vault The address of the main Vault"}}},"version":1},"userdoc":{"kind":"user","methods":{"addLiquidityToBuffer(address,uint256,address)":{"notice":"Adds liquidity to an internal ERC4626 buffer in the Vault, proportionally."},"areBuffersPaused()":{"notice":"Indicates whether the Vault buffers are paused."},"collectAggregateFees(address)":{"notice":"Collects accumulated aggregate swap and yield fees for the specified pool."},"disableQuery()":{"notice":"Disables queries functionality on the Vault. Can only be called by governance."},"disableRecoveryMode(address)":{"notice":"Disable recovery mode for a pool."},"enableRecoveryMode(address)":{"notice":"Enable recovery mode for a pool."},"getBufferAsset(address)":{"notice":"Returns the asset registered for a given wrapped token."},"getBufferBalance(address)":{"notice":"Returns the amount of underlying and wrapped tokens deposited in the internal buffer of the Vault."},"getBufferMinimumTotalSupply()":{"notice":"Get the minimum total supply of an ERC4626 wrapped token buffer in the Vault."},"getBufferOwnerShares(address,address)":{"notice":"Returns the shares (internal buffer BPT) of a liquidity owner: a user that deposited assets in the buffer."},"getBufferPeriodDuration()":{"notice":"Returns the Vault's buffer period duration."},"getBufferPeriodEndTime()":{"notice":"Returns the Vault's buffer period end time."},"getBufferTotalShares(address)":{"notice":"Returns the supply shares (internal buffer BPT) of the ERC4626 buffer."},"getMaximumPoolTokens()":{"notice":"Get the maximum number of tokens in a pool."},"getMinimumPoolTokens()":{"notice":"Get the minimum number of tokens in a pool."},"getMinimumTradeAmount()":{"notice":"Get the minimum trade amount in a pool operation."},"getMinimumWrapAmount()":{"notice":"Get the minimum wrap amount in a buffer operation."},"getPauseWindowEndTime()":{"notice":"Returns the Vault's pause window end time."},"getPoolMinimumTotalSupply()":{"notice":"Get the minimum total supply of pool tokens (BPT) for an initialized pool."},"getVaultPausedState()":{"notice":"Returns the paused status, and end times of the Vault's pause window and buffer period."},"initializeBuffer(address,uint256,uint256,address)":{"notice":"Initializes buffer for the given wrapped token."},"isVaultPaused()":{"notice":"Indicates whether the Vault is paused."},"pausePool(address)":{"notice":"Pause the Pool: an emergency action which disables all pool functions."},"pauseVault()":{"notice":"Pause the Vault: an emergency action which disables all operational state-changing functions."},"pauseVaultBuffers()":{"notice":"Pauses native vault buffers globally."},"removeLiquidityFromBuffer(address,uint256)":{"notice":"Removes liquidity from an internal ERC4626 buffer in the Vault."},"setAuthorizer(address)":{"notice":"Sets a new Authorizer for the Vault."},"setProtocolFeeController(address)":{"notice":"Sets a new Protocol Fee Controller for the Vault."},"setStaticSwapFeePercentage(address,uint256)":{"notice":"Assigns a new static swap fee percentage to the specified pool."},"unpausePool(address)":{"notice":"Reverse a `pause` operation, and restore the Pool to normal functionality."},"unpauseVault()":{"notice":"Reverse a `pause` operation, and restore the Vault to normal functionality."},"unpauseVaultBuffers()":{"notice":"Unpauses native vault buffers globally."},"updateAggregateSwapFeePercentage(address,uint256)":{"notice":"Update an aggregate swap fee percentage."},"updateAggregateYieldFeePercentage(address,uint256)":{"notice":"Update an aggregate yield fee percentage."},"vault()":{"notice":"Returns the main Vault address."}},"version":1}},"settings":{"remappings":["@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/","@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/","@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/","@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/","@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/","@openzeppelin/=lib/openzeppelin-contracts/","@test/=lib/balancer-v3-monorepo/pkg/","ds-test/=../../node_modules/forge-std/lib/ds-test/src/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","permit2/=lib/permit2/","pool-weighted/=../pool-weighted/","solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/","solidity-utils/=../solidity-utils/","vault/=../vault/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol":"IVaultAdmin"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IAuthentication.sol":{"keccak256":"0x3c4c0cf4d69eec7f6ad108391607be00f1f7ef9867eb7ba03738d61d052c2ed2","urls":["bzz-raw://023b1414a8ef990cfcc3af005f540c70539b0107feb2103d0c2f70ccdad41a87","dweb:/ipfs/QmdJuumhraGU5Vjs9QZDATSV4VXEoPdmH6nuM7aNxgmRQo"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906","urls":["bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452","dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol":{"keccak256":"0x974e40f9ec0da0d2cce5d6e469407fb2d9c3a85f86dd2bb0b182a393ba661e0a","urls":["bzz-raw://d069400e563125436cb97dc09961b4fe355a1a3a9cabf6b111053a1a6ae0984c","dweb:/ipfs/QmVtH4vLfRpz5KpkSqGw4BSXpUhZv1Um2DSkJhb32xsUDy"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol":{"keccak256":"0x90f77758dbdfdb952754aa3fbfbdf816afb9592b49a12932cf6636bb6dab6638","urls":["bzz-raw://bf3a76192ee4290f81c33dcc28889761087b0f3f5324bdf0c5487504a349df5f","dweb:/ipfs/QmX5tH5yox4riErpQ43BEmc7L11C65ob53gRQ5VUBdNM3Y"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IProtocolFeeController.sol":{"keccak256":"0x265cba6f0225fae5867e47ead3b7d51ea124c6599d450b361bb86795ffb0a586","urls":["bzz-raw://9363b61e7b592c6d9476cfcdc9d468669f3e9d2d232ad426f6c5c6c00247258e","dweb:/ipfs/QmT771Kpp4VswEcBCJCMxKKKiRNMcLJeziKCisjLrc2opx"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVault.sol":{"keccak256":"0xdc75f953e7fcb8dee0f26935ce638cfb515f512719bfe5c57e117f366b2cbb7c","urls":["bzz-raw://4ec167998306d37a2c4e2ab76cee77d252e5f868019f3a038241227c7a06e566","dweb:/ipfs/QmQfB1yvkSrcZpTThv3TuuT7zvKfU1euVAf1av2hPuj9GH"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol":{"keccak256":"0xe68fbe2bef8c4fda8cf43d186d0e5518f9d76e57ac1c2f8082a1d0bcf444ace7","urls":["bzz-raw://614fb11ff5f7ea15cab882dfe4c7f69656eb5ad0e7cb217338664d8f1d0403c7","dweb:/ipfs/QmUPZRXKFLsGEiPM38uDz14EVvJV81NCNBoWajmAbEmDka"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultErrors.sol":{"keccak256":"0x3bf1cfa4716401af08fd265db6ebbaad011d94d4531be5a6289aafbe4dc02f0f","urls":["bzz-raw://7969b076f81af1fec02a0cc572ea56be691315bbcc761bb47e38aecb86ae15fc","dweb:/ipfs/QmPkYWjEEj9Kzrbhcc6i8mmB1WAopcf13Ue2ZhayTXtnBm"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultEvents.sol":{"keccak256":"0xfa87a090e0b1fc87e34b6a891b7abd4697e75997e37d073020b91c7c408bffe3","urls":["bzz-raw://2b33f211008d57462d8b4598b78e477ce6ee53f0c1172682b94e896954752fe9","dweb:/ipfs/QmVzjPRey6qss4ucJx3Mb1gs5MAyLKcLUD5tLt9KNn2SNR"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultExtension.sol":{"keccak256":"0x2c6f4f4d714a0f1e7e648909753839da8182117f22018f4337f9632f9c40597b","urls":["bzz-raw://99fb94d7fcf9f972f4aec716d7d4be43e3d28f90f8f5923b9b8245be178e01aa","dweb:/ipfs/QmeLSFfcvYwmPpQ58yESVjYXPY13NzGU28WjxkWUj8sgqx"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultMain.sol":{"keccak256":"0x976def53871db0ad0db3504086a783508b0c293b86364c8985d6700283986799","urls":["bzz-raw://e9a2904288327a95373e32d99b2244a7afcf9f741b970ff34af6a933076076e6","dweb:/ipfs/QmaS4adLMjzagUsqYhtxo7KJW2kZogx5orQgvfVzLR3dzW"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3","urls":["bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3","dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf"],"license":"GPL-3.0-or-later"},"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol":{"keccak256":"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06","urls":["bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf","dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4","urls":["bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009","dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28","urls":["bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323","dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR"],"license":"MIT"}},"version":1},"ast":{"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVaultAdmin.sol","id":5301,"exportedSymbols":{"IAuthorizer":[3638],"IERC4626":[51483],"IProtocolFeeController":[4363],"IVault":[5028],"IVaultAdmin":[5300]},"nodeType":"SourceUnit","src":"46:19270:32","nodes":[{"id":5030,"nodeType":"PragmaDirective","src":"46:24:32","nodes":[],"literals":["solidity","^","0.8",".24"]},{"id":5032,"nodeType":"ImportDirective","src":"72:75:32","nodes":[],"absolutePath":"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol","file":"@openzeppelin/contracts/interfaces/IERC4626.sol","nameLocation":"-1:-1:-1","scope":5301,"sourceUnit":51484,"symbolAliases":[{"foreign":{"id":5031,"name":"IERC4626","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":51483,"src":"81:8:32","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":5034,"nodeType":"ImportDirective","src":"149:70:32","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IProtocolFeeController.sol","file":"./IProtocolFeeController.sol","nameLocation":"-1:-1:-1","scope":5301,"sourceUnit":4364,"symbolAliases":[{"foreign":{"id":5033,"name":"IProtocolFeeController","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":4363,"src":"158:22:32","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":5036,"nodeType":"ImportDirective","src":"220:48:32","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IAuthorizer.sol","file":"./IAuthorizer.sol","nameLocation":"-1:-1:-1","scope":5301,"sourceUnit":3639,"symbolAliases":[{"foreign":{"id":5035,"name":"IAuthorizer","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":3638,"src":"229:11:32","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":5038,"nodeType":"ImportDirective","src":"269:38:32","nodes":[],"absolutePath":"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IVault.sol","file":"./IVault.sol","nameLocation":"-1:-1:-1","scope":5301,"sourceUnit":5029,"symbolAliases":[{"foreign":{"id":5037,"name":"IVault","nodeType":"Identifier","overloadedDeclarations":[],"referencedDeclaration":5028,"src":"278:6:32","typeDescriptions":{}},"nameLocation":"-1:-1:-1"}],"unitAlias":""},{"id":5300,"nodeType":"ContractDefinition","src":"586:18729:32","nodes":[{"id":5046,"nodeType":"FunctionDefinition","src":"1052:48:32","nodes":[],"documentation":{"id":5040,"nodeType":"StructuredDocumentation","src":"841:206:32","text":" @notice Returns the main Vault address.\n @dev The main Vault contains the entrypoint and main liquidity operation implementations.\n @return vault The address of the main Vault"},"functionSelector":"fbfa77cf","implemented":false,"kind":"function","modifiers":[],"name":"vault","nameLocation":"1061:5:32","parameters":{"id":5041,"nodeType":"ParameterList","parameters":[],"src":"1066:2:32"},"returnParameters":{"id":5045,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5044,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5046,"src":"1092:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IVault_$5028","typeString":"contract IVault"},"typeName":{"id":5043,"nodeType":"UserDefinedTypeName","pathNode":{"id":5042,"name":"IVault","nameLocations":["1092:6:32"],"nodeType":"IdentifierPath","referencedDeclaration":5028,"src":"1092:6:32"},"referencedDeclaration":5028,"src":"1092:6:32","typeDescriptions":{"typeIdentifier":"t_contract$_IVault_$5028","typeString":"contract IVault"}},"visibility":"internal"}],"src":"1091:8:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5052,"nodeType":"FunctionDefinition","src":"1404:64:32","nodes":[],"documentation":{"id":5047,"nodeType":"StructuredDocumentation","src":"1106:293:32","text":" @notice Returns the Vault's pause window end time.\n @dev This value is immutable, and represents the timestamp after which the Vault can no longer be paused\n by governance.\n @return pauseWindowEndTime The timestamp when the Vault's pause window ends"},"functionSelector":"8a8d123a","implemented":false,"kind":"function","modifiers":[],"name":"getPauseWindowEndTime","nameLocation":"1413:21:32","parameters":{"id":5048,"nodeType":"ParameterList","parameters":[],"src":"1434:2:32"},"returnParameters":{"id":5051,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5050,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5052,"src":"1460:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"},"typeName":{"id":5049,"name":"uint32","nodeType":"ElementaryTypeName","src":"1460:6:32","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"}},"visibility":"internal"}],"src":"1459:8:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5058,"nodeType":"FunctionDefinition","src":"1853:66:32","nodes":[],"documentation":{"id":5053,"nodeType":"StructuredDocumentation","src":"1474:374:32","text":" @notice Returns the Vault's buffer period duration.\n @dev This value is immutable. It represents the period during which, if paused, the Vault will remain paused.\n This ensures there is time available to address whatever issue caused the Vault to be paused.\n @return bufferPeriodDuration The length of the buffer period in seconds"},"functionSelector":"20c1fb7a","implemented":false,"kind":"function","modifiers":[],"name":"getBufferPeriodDuration","nameLocation":"1862:23:32","parameters":{"id":5054,"nodeType":"ParameterList","parameters":[],"src":"1885:2:32"},"returnParameters":{"id":5057,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5056,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5058,"src":"1911:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"},"typeName":{"id":5055,"name":"uint32","nodeType":"ElementaryTypeName","src":"1911:6:32","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"}},"visibility":"internal"}],"src":"1910:8:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5064,"nodeType":"FunctionDefinition","src":"2204:65:32","nodes":[],"documentation":{"id":5059,"nodeType":"StructuredDocumentation","src":"1925:274:32","text":" @notice Returns the Vault's buffer period end time.\n @dev This value is immutable. If already paused, the Vault can be unpaused until this timestamp.\n @return bufferPeriodEndTime The timestamp after which the Vault remains permanently unpaused"},"functionSelector":"cd51c12f","implemented":false,"kind":"function","modifiers":[],"name":"getBufferPeriodEndTime","nameLocation":"2213:22:32","parameters":{"id":5060,"nodeType":"ParameterList","parameters":[],"src":"2235:2:32"},"returnParameters":{"id":5063,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5062,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5064,"src":"2261:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"},"typeName":{"id":5061,"name":"uint32","nodeType":"ElementaryTypeName","src":"2261:6:32","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"}},"visibility":"internal"}],"src":"2260:8:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5070,"nodeType":"FunctionDefinition","src":"2473:64:32","nodes":[],"documentation":{"id":5065,"nodeType":"StructuredDocumentation","src":"2275:193:32","text":" @notice Get the minimum number of tokens in a pool.\n @dev We expect the vast majority of pools to be 2-token.\n @return minTokens The minimum token count of a pool"},"functionSelector":"a8175b27","implemented":false,"kind":"function","modifiers":[],"name":"getMinimumPoolTokens","nameLocation":"2482:20:32","parameters":{"id":5066,"nodeType":"ParameterList","parameters":[],"src":"2502:2:32"},"returnParameters":{"id":5069,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5068,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5070,"src":"2528:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5067,"name":"uint256","nodeType":"ElementaryTypeName","src":"2528:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2527:9:32"},"scope":5300,"stateMutability":"pure","virtual":false,"visibility":"external"},{"id":5076,"nodeType":"FunctionDefinition","src":"2677:64:32","nodes":[],"documentation":{"id":5071,"nodeType":"StructuredDocumentation","src":"2543:129:32","text":" @notice Get the maximum number of tokens in a pool.\n @return maxTokens The maximum token count of a pool"},"functionSelector":"2e42f4d5","implemented":false,"kind":"function","modifiers":[],"name":"getMaximumPoolTokens","nameLocation":"2686:20:32","parameters":{"id":5072,"nodeType":"ParameterList","parameters":[],"src":"2706:2:32"},"returnParameters":{"id":5075,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5074,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5076,"src":"2732:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5073,"name":"uint256","nodeType":"ElementaryTypeName","src":"2732:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"2731:9:32"},"scope":5300,"stateMutability":"pure","virtual":false,"visibility":"external"},{"id":5082,"nodeType":"FunctionDefinition","src":"3187:69:32","nodes":[],"documentation":{"id":5077,"nodeType":"StructuredDocumentation","src":"2747:435:32","text":" @notice Get the minimum total supply of pool tokens (BPT) for an initialized pool.\n @dev This prevents pools from being completely drained. When the pool is initialized, this minimum amount of BPT\n is minted to the zero address. This is an 18-decimal floating point number; BPT are always 18 decimals.\n @return minimumTotalSupply The minimum total supply a pool can have after initialization"},"functionSelector":"d0965a6b","implemented":false,"kind":"function","modifiers":[],"name":"getPoolMinimumTotalSupply","nameLocation":"3196:25:32","parameters":{"id":5078,"nodeType":"ParameterList","parameters":[],"src":"3221:2:32"},"returnParameters":{"id":5081,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5080,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5082,"src":"3247:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5079,"name":"uint256","nodeType":"ElementaryTypeName","src":"3247:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3246:9:32"},"scope":5300,"stateMutability":"pure","virtual":false,"visibility":"external"},{"id":5088,"nodeType":"FunctionDefinition","src":"3763:71:32","nodes":[],"documentation":{"id":5083,"nodeType":"StructuredDocumentation","src":"3262:496:32","text":" @notice Get the minimum total supply of an ERC4626 wrapped token buffer in the Vault.\n @dev This prevents buffers from being completely drained. When the buffer is initialized, this minimum number\n of shares is added to the shares resulting from the initial deposit. Buffer total supply accounting is internal\n to the Vault, as buffers are not tokenized.\n @return minimumTotalSupply The minimum total supply a buffer can have after initialization"},"functionSelector":"26a8a991","implemented":false,"kind":"function","modifiers":[],"name":"getBufferMinimumTotalSupply","nameLocation":"3772:27:32","parameters":{"id":5084,"nodeType":"ParameterList","parameters":[],"src":"3799:2:32"},"returnParameters":{"id":5087,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5086,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5088,"src":"3825:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5085,"name":"uint256","nodeType":"ElementaryTypeName","src":"3825:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"3824:9:32"},"scope":5300,"stateMutability":"pure","virtual":false,"visibility":"external"},{"id":5094,"nodeType":"FunctionDefinition","src":"4136:65:32","nodes":[],"documentation":{"id":5089,"nodeType":"StructuredDocumentation","src":"3840:291:32","text":" @notice Get the minimum trade amount in a pool operation.\n @dev This limit is applied to the 18-decimal \"upscaled\" amount in any operation (swap, add/remove liquidity).\n @return minimumTradeAmount The minimum trade amount as an 18-decimal floating point number"},"functionSelector":"e2cb0ba0","implemented":false,"kind":"function","modifiers":[],"name":"getMinimumTradeAmount","nameLocation":"4145:21:32","parameters":{"id":5090,"nodeType":"ParameterList","parameters":[],"src":"4166:2:32"},"returnParameters":{"id":5093,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5092,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5094,"src":"4192:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5091,"name":"uint256","nodeType":"ElementaryTypeName","src":"4192:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"4191:9:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5100,"nodeType":"FunctionDefinition","src":"4483:64:32","nodes":[],"documentation":{"id":5095,"nodeType":"StructuredDocumentation","src":"4207:271:32","text":" @notice Get the minimum wrap amount in a buffer operation.\n @dev This limit is applied to the wrap operation amount, in native underlying token decimals.\n @return minimumWrapAmount The minimum wrap amount in native underlying token decimals"},"functionSelector":"53956aa2","implemented":false,"kind":"function","modifiers":[],"name":"getMinimumWrapAmount","nameLocation":"4492:20:32","parameters":{"id":5096,"nodeType":"ParameterList","parameters":[],"src":"4512:2:32"},"returnParameters":{"id":5099,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5098,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5100,"src":"4538:7:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5097,"name":"uint256","nodeType":"ElementaryTypeName","src":"4538:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"4537:9:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5106,"nodeType":"FunctionDefinition","src":"4991:54:32","nodes":[],"documentation":{"id":5101,"nodeType":"StructuredDocumentation","src":"4774:212:32","text":" @notice Indicates whether the Vault is paused.\n @dev If the Vault is paused, all non-Recovery Mode state-changing operations will revert.\n @return paused True if the Vault is paused"},"functionSelector":"098401f5","implemented":false,"kind":"function","modifiers":[],"name":"isVaultPaused","nameLocation":"5000:13:32","parameters":{"id":5102,"nodeType":"ParameterList","parameters":[],"src":"5013:2:32"},"returnParameters":{"id":5105,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5104,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5106,"src":"5039:4:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":5103,"name":"bool","nodeType":"ElementaryTypeName","src":"5039:4:32","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"5038:6:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5116,"nodeType":"FunctionDefinition","src":"5406:76:32","nodes":[],"documentation":{"id":5107,"nodeType":"StructuredDocumentation","src":"5051:350:32","text":" @notice Returns the paused status, and end times of the Vault's pause window and buffer period.\n @return paused True if the Vault is paused\n @return vaultPauseWindowEndTime The timestamp of the end of the Vault's pause window\n @return vaultBufferPeriodEndTime The timestamp of the end of the Vault's buffer period"},"functionSelector":"85c8c015","implemented":false,"kind":"function","modifiers":[],"name":"getVaultPausedState","nameLocation":"5415:19:32","parameters":{"id":5108,"nodeType":"ParameterList","parameters":[],"src":"5434:2:32"},"returnParameters":{"id":5115,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5110,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5116,"src":"5460:4:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":5109,"name":"bool","nodeType":"ElementaryTypeName","src":"5460:4:32","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"},{"constant":false,"id":5112,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5116,"src":"5466:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"},"typeName":{"id":5111,"name":"uint32","nodeType":"ElementaryTypeName","src":"5466:6:32","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"}},"visibility":"internal"},{"constant":false,"id":5114,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5116,"src":"5474:6:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"},"typeName":{"id":5113,"name":"uint32","nodeType":"ElementaryTypeName","src":"5474:6:32","typeDescriptions":{"typeIdentifier":"t_uint32","typeString":"uint32"}},"visibility":"internal"}],"src":"5459:22:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5120,"nodeType":"FunctionDefinition","src":"5724:31:32","nodes":[],"documentation":{"id":5117,"nodeType":"StructuredDocumentation","src":"5488:231:32","text":" @notice Pause the Vault: an emergency action which disables all operational state-changing functions.\n @dev This is a permissioned function that will only work during the Pause Window set during deployment."},"functionSelector":"9e0879c2","implemented":false,"kind":"function","modifiers":[],"name":"pauseVault","nameLocation":"5733:10:32","parameters":{"id":5118,"nodeType":"ParameterList","parameters":[],"src":"5743:2:32"},"returnParameters":{"id":5119,"nodeType":"ParameterList","parameters":[],"src":"5754:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5124,"nodeType":"FunctionDefinition","src":"6085:33:32","nodes":[],"documentation":{"id":5121,"nodeType":"StructuredDocumentation","src":"5761:319:32","text":" @notice Reverse a `pause` operation, and restore the Vault to normal functionality.\n @dev This is a permissioned function that will only work on a paused Vault within the Buffer Period set during\n deployment. Note that the Vault will automatically unpause after the Buffer Period expires."},"functionSelector":"0b7562be","implemented":false,"kind":"function","modifiers":[],"name":"unpauseVault","nameLocation":"6094:12:32","parameters":{"id":5122,"nodeType":"ParameterList","parameters":[],"src":"6106:2:32"},"returnParameters":{"id":5123,"nodeType":"ParameterList","parameters":[],"src":"6117:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5130,"nodeType":"FunctionDefinition","src":"6625:42:32","nodes":[],"documentation":{"id":5125,"nodeType":"StructuredDocumentation","src":"6344:276:32","text":" @notice Pause the Pool: an emergency action which disables all pool functions.\n @dev This is a permissioned function that will only work during the Pause Window set during pool factory\n deployment.\n @param pool The pool being paused"},"functionSelector":"55aca1ec","implemented":false,"kind":"function","modifiers":[],"name":"pausePool","nameLocation":"6634:9:32","parameters":{"id":5128,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5127,"mutability":"mutable","name":"pool","nameLocation":"6652:4:32","nodeType":"VariableDeclaration","scope":5130,"src":"6644:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5126,"name":"address","nodeType":"ElementaryTypeName","src":"6644:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"6643:14:32"},"returnParameters":{"id":5129,"nodeType":"ParameterList","parameters":[],"src":"6666:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5136,"nodeType":"FunctionDefinition","src":"7044:44:32","nodes":[],"documentation":{"id":5131,"nodeType":"StructuredDocumentation","src":"6673:366:32","text":" @notice Reverse a `pause` operation, and restore the Pool to normal functionality.\n @dev This is a permissioned function that will only work on a paused Pool within the Buffer Period set during\n deployment. Note that the Pool will automatically unpause after the Buffer Period expires.\n @param pool The pool being unpaused"},"functionSelector":"f21c38cd","implemented":false,"kind":"function","modifiers":[],"name":"unpausePool","nameLocation":"7053:11:32","parameters":{"id":5134,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5133,"mutability":"mutable","name":"pool","nameLocation":"7073:4:32","nodeType":"VariableDeclaration","scope":5136,"src":"7065:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5132,"name":"address","nodeType":"ElementaryTypeName","src":"7065:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"7064:14:32"},"returnParameters":{"id":5135,"nodeType":"ParameterList","parameters":[],"src":"7087:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5144,"nodeType":"FunctionDefinition","src":"7830:86:32","nodes":[],"documentation":{"id":5137,"nodeType":"StructuredDocumentation","src":"7305:520:32","text":" @notice Assigns a new static swap fee percentage to the specified pool.\n @dev This is a permissioned function, disabled if the pool is paused. The swap fee percentage must be within\n the bounds specified by the pool's implementation of `ISwapFeePercentageBounds`.\n Emits the SwapFeePercentageChanged event.\n @param pool The address of the pool for which the static swap fee will be changed\n @param swapFeePercentage The new swap fee percentage to apply to the pool"},"functionSelector":"d15126ba","implemented":false,"kind":"function","modifiers":[],"name":"setStaticSwapFeePercentage","nameLocation":"7839:26:32","parameters":{"id":5142,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5139,"mutability":"mutable","name":"pool","nameLocation":"7874:4:32","nodeType":"VariableDeclaration","scope":5144,"src":"7866:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5138,"name":"address","nodeType":"ElementaryTypeName","src":"7866:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":5141,"mutability":"mutable","name":"swapFeePercentage","nameLocation":"7888:17:32","nodeType":"VariableDeclaration","scope":5144,"src":"7880:25:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5140,"name":"uint256","nodeType":"ElementaryTypeName","src":"7880:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"7865:41:32"},"returnParameters":{"id":5143,"nodeType":"ParameterList","parameters":[],"src":"7915:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5156,"nodeType":"FunctionDefinition","src":"8390:143:32","nodes":[],"documentation":{"id":5145,"nodeType":"StructuredDocumentation","src":"7922:463:32","text":" @notice Collects accumulated aggregate swap and yield fees for the specified pool.\n @dev Fees are sent to the ProtocolFeeController address.\n @param pool The pool on which all aggregate fees should be collected\n @return swapFeeAmounts An array with the total swap fees collected, sorted in token registration order\n @return yieldFeeAmounts An array with the total yield fees collected, sorted in token registration order"},"functionSelector":"8f4ab9ca","implemented":false,"kind":"function","modifiers":[],"name":"collectAggregateFees","nameLocation":"8399:20:32","parameters":{"id":5148,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5147,"mutability":"mutable","name":"pool","nameLocation":"8437:4:32","nodeType":"VariableDeclaration","scope":5156,"src":"8429:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5146,"name":"address","nodeType":"ElementaryTypeName","src":"8429:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"8419:28:32"},"returnParameters":{"id":5155,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5151,"mutability":"mutable","name":"swapFeeAmounts","nameLocation":"8483:14:32","nodeType":"VariableDeclaration","scope":5156,"src":"8466:31:32","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":5149,"name":"uint256","nodeType":"ElementaryTypeName","src":"8466:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":5150,"nodeType":"ArrayTypeName","src":"8466:9:32","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"},{"constant":false,"id":5154,"mutability":"mutable","name":"yieldFeeAmounts","nameLocation":"8516:15:32","nodeType":"VariableDeclaration","scope":5156,"src":"8499:32:32","stateVariable":false,"storageLocation":"memory","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_memory_ptr","typeString":"uint256[]"},"typeName":{"baseType":{"id":5152,"name":"uint256","nodeType":"ElementaryTypeName","src":"8499:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"id":5153,"nodeType":"ArrayTypeName","src":"8499:9:32","typeDescriptions":{"typeIdentifier":"t_array$_t_uint256_$dyn_storage_ptr","typeString":"uint256[]"}},"visibility":"internal"}],"src":"8465:67:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5164,"nodeType":"FunctionDefinition","src":"9283:104:32","nodes":[],"documentation":{"id":5157,"nodeType":"StructuredDocumentation","src":"8539:739:32","text":" @notice Update an aggregate swap fee percentage.\n @dev Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee\n for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's\n fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also\n that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol).\n Emits an `AggregateSwapFeePercentageChanged` event.\n @param pool The pool whose fee will be updated\n @param newAggregateSwapFeePercentage The new aggregate swap fee percentage"},"functionSelector":"5e0b06f4","implemented":false,"kind":"function","modifiers":[],"name":"updateAggregateSwapFeePercentage","nameLocation":"9292:32:32","parameters":{"id":5162,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5159,"mutability":"mutable","name":"pool","nameLocation":"9333:4:32","nodeType":"VariableDeclaration","scope":5164,"src":"9325:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5158,"name":"address","nodeType":"ElementaryTypeName","src":"9325:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":5161,"mutability":"mutable","name":"newAggregateSwapFeePercentage","nameLocation":"9347:29:32","nodeType":"VariableDeclaration","scope":5164,"src":"9339:37:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5160,"name":"uint256","nodeType":"ElementaryTypeName","src":"9339:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"9324:53:32"},"returnParameters":{"id":5163,"nodeType":"ParameterList","parameters":[],"src":"9386:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5172,"nodeType":"FunctionDefinition","src":"10141:106:32","nodes":[],"documentation":{"id":5165,"nodeType":"StructuredDocumentation","src":"9393:743:32","text":" @notice Update an aggregate yield fee percentage.\n @dev Can only be called by the current protocol fee controller. Called when governance overrides a protocol fee\n for a specific pool, or to permissionlessly update a pool to a changed global protocol fee value (if the pool's\n fee has not previously been set by governance). Ensures the aggregate percentage <= FixedPoint.ONE, and also\n that the final value does not lose precision when stored in 24 bits (see `FEE_BITLENGTH` in VaultTypes.sol).\n Emits an `AggregateYieldFeePercentageChanged` event.\n @param pool The pool whose fee will be updated\n @param newAggregateYieldFeePercentage The new aggregate yield fee percentage"},"functionSelector":"e253670a","implemented":false,"kind":"function","modifiers":[],"name":"updateAggregateYieldFeePercentage","nameLocation":"10150:33:32","parameters":{"id":5170,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5167,"mutability":"mutable","name":"pool","nameLocation":"10192:4:32","nodeType":"VariableDeclaration","scope":5172,"src":"10184:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5166,"name":"address","nodeType":"ElementaryTypeName","src":"10184:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"},{"constant":false,"id":5169,"mutability":"mutable","name":"newAggregateYieldFeePercentage","nameLocation":"10206:30:32","nodeType":"VariableDeclaration","scope":5172,"src":"10198:38:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5168,"name":"uint256","nodeType":"ElementaryTypeName","src":"10198:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"10183:54:32"},"returnParameters":{"id":5171,"nodeType":"ParameterList","parameters":[],"src":"10246:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5179,"nodeType":"FunctionDefinition","src":"10507:92:32","nodes":[],"documentation":{"id":5173,"nodeType":"StructuredDocumentation","src":"10253:249:32","text":" @notice Sets a new Protocol Fee Controller for the Vault.\n @dev This is a permissioned call. Emits a `ProtocolFeeControllerChanged` event.\n @param newProtocolFeeController The address of the new Protocol Fee Controller"},"functionSelector":"2d771389","implemented":false,"kind":"function","modifiers":[],"name":"setProtocolFeeController","nameLocation":"10516:24:32","parameters":{"id":5177,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5176,"mutability":"mutable","name":"newProtocolFeeController","nameLocation":"10564:24:32","nodeType":"VariableDeclaration","scope":5179,"src":"10541:47:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IProtocolFeeController_$4363","typeString":"contract IProtocolFeeController"},"typeName":{"id":5175,"nodeType":"UserDefinedTypeName","pathNode":{"id":5174,"name":"IProtocolFeeController","nameLocations":["10541:22:32"],"nodeType":"IdentifierPath","referencedDeclaration":4363,"src":"10541:22:32"},"referencedDeclaration":4363,"src":"10541:22:32","typeDescriptions":{"typeIdentifier":"t_contract$_IProtocolFeeController_$4363","typeString":"contract IProtocolFeeController"}},"visibility":"internal"}],"src":"10540:49:32"},"returnParameters":{"id":5178,"nodeType":"ParameterList","parameters":[],"src":"10598:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5185,"nodeType":"FunctionDefinition","src":"11150:51:32","nodes":[],"documentation":{"id":5180,"nodeType":"StructuredDocumentation","src":"10826:319:32","text":" @notice Enable recovery mode for a pool.\n @dev This is a permissioned function. It enables a safe proportional withdrawal, with no external calls.\n Since there are no external calls, live balances cannot be updated while in Recovery Mode.\n @param pool The address of the pool"},"functionSelector":"dc3f574e","implemented":false,"kind":"function","modifiers":[],"name":"enableRecoveryMode","nameLocation":"11159:18:32","parameters":{"id":5183,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5182,"mutability":"mutable","name":"pool","nameLocation":"11186:4:32","nodeType":"VariableDeclaration","scope":5185,"src":"11178:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5181,"name":"address","nodeType":"ElementaryTypeName","src":"11178:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"11177:14:32"},"returnParameters":{"id":5184,"nodeType":"ParameterList","parameters":[],"src":"11200:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5191,"nodeType":"FunctionDefinition","src":"11621:52:32","nodes":[],"documentation":{"id":5186,"nodeType":"StructuredDocumentation","src":"11207:409:32","text":" @notice Disable recovery mode for a pool.\n @dev This is a permissioned function. It re-syncs live balances (which could not be updated during\n Recovery Mode), forfeiting any yield fees that accrued while enabled. It makes external calls, and could\n potentially fail if there is an issue with any associated Rate Providers.\n @param pool The address of the pool"},"functionSelector":"bffb78b2","implemented":false,"kind":"function","modifiers":[],"name":"disableRecoveryMode","nameLocation":"11630:19:32","parameters":{"id":5189,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5188,"mutability":"mutable","name":"pool","nameLocation":"11658:4:32","nodeType":"VariableDeclaration","scope":5191,"src":"11650:12:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5187,"name":"address","nodeType":"ElementaryTypeName","src":"11650:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"11649:14:32"},"returnParameters":{"id":5190,"nodeType":"ParameterList","parameters":[],"src":"11672:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5195,"nodeType":"FunctionDefinition","src":"11989:33:32","nodes":[],"documentation":{"id":5192,"nodeType":"StructuredDocumentation","src":"11894:90:32","text":"@notice Disables queries functionality on the Vault. Can only be called by governance."},"functionSelector":"de1a36a6","implemented":false,"kind":"function","modifiers":[],"name":"disableQuery","nameLocation":"11998:12:32","parameters":{"id":5193,"nodeType":"ParameterList","parameters":[],"src":"12010:2:32"},"returnParameters":{"id":5194,"nodeType":"ParameterList","parameters":[],"src":"12021:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5201,"nodeType":"FunctionDefinition","src":"12560:57:32","nodes":[],"documentation":{"id":5196,"nodeType":"StructuredDocumentation","src":"12249:306:32","text":" @notice Indicates whether the Vault buffers are paused.\n @dev When buffers are paused, all buffer operations (i.e., calls on the Router with `isBuffer` true)\n will revert. Pausing buffers is reversible.\n @return buffersPaused True if the Vault buffers are paused"},"functionSelector":"55cba7fe","implemented":false,"kind":"function","modifiers":[],"name":"areBuffersPaused","nameLocation":"12569:16:32","parameters":{"id":5197,"nodeType":"ParameterList","parameters":[],"src":"12585:2:32"},"returnParameters":{"id":5200,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5199,"mutability":"mutable","name":"","nameLocation":"-1:-1:-1","nodeType":"VariableDeclaration","scope":5201,"src":"12611:4:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"},"typeName":{"id":5198,"name":"bool","nodeType":"ElementaryTypeName","src":"12611:4:32","typeDescriptions":{"typeIdentifier":"t_bool","typeString":"bool"}},"visibility":"internal"}],"src":"12610:6:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5205,"nodeType":"FunctionDefinition","src":"13062:38:32","nodes":[],"documentation":{"id":5202,"nodeType":"StructuredDocumentation","src":"12623:434:32","text":" @notice Pauses native vault buffers globally.\n @dev When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's\n `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity. Currently it's not\n possible to pause vault buffers individually.\n This is a permissioned call, and is reversible (see `unpauseVaultBuffers`)."},"functionSelector":"e085c5a8","implemented":false,"kind":"function","modifiers":[],"name":"pauseVaultBuffers","nameLocation":"13071:17:32","parameters":{"id":5203,"nodeType":"ParameterList","parameters":[],"src":"13088:2:32"},"returnParameters":{"id":5204,"nodeType":"ParameterList","parameters":[],"src":"13099:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5209,"nodeType":"FunctionDefinition","src":"13428:40:32","nodes":[],"documentation":{"id":5206,"nodeType":"StructuredDocumentation","src":"13106:317:32","text":" @notice Unpauses native vault buffers globally.\n @dev When buffers are paused, it's not possible to add liquidity or wrap/unwrap tokens using the Vault's\n `erc4626BufferWrapOrUnwrap` primitive. However, it's still possible to remove liquidity.\n This is a permissioned call."},"functionSelector":"b9212b49","implemented":false,"kind":"function","modifiers":[],"name":"unpauseVaultBuffers","nameLocation":"13437:19:32","parameters":{"id":5207,"nodeType":"ParameterList","parameters":[],"src":"13456:2:32"},"returnParameters":{"id":5208,"nodeType":"ParameterList","parameters":[],"src":"13467:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5224,"nodeType":"FunctionDefinition","src":"14203:203:32","nodes":[],"documentation":{"id":5210,"nodeType":"StructuredDocumentation","src":"13474:724:32","text":" @notice Initializes buffer for the given wrapped token.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @param amountUnderlyingRaw Amount of underlying tokens that will be deposited into the buffer\n @param amountWrappedRaw Amount of wrapped tokens that will be deposited into the buffer\n @param sharesOwner Address that will own the deposited liquidity. Only this address will be able to remove\n liquidity from the buffer\n @return issuedShares the amount of tokens sharesOwner has in the buffer, expressed in underlying token amounts.\n (it is the BPT of an internal ERC4626 buffer). It is expressed in underlying token native decimals."},"functionSelector":"40058e35","implemented":false,"kind":"function","modifiers":[],"name":"initializeBuffer","nameLocation":"14212:16:32","parameters":{"id":5220,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5213,"mutability":"mutable","name":"wrappedToken","nameLocation":"14247:12:32","nodeType":"VariableDeclaration","scope":5224,"src":"14238:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5212,"nodeType":"UserDefinedTypeName","pathNode":{"id":5211,"name":"IERC4626","nameLocations":["14238:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"14238:8:32"},"referencedDeclaration":51483,"src":"14238:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"},{"constant":false,"id":5215,"mutability":"mutable","name":"amountUnderlyingRaw","nameLocation":"14277:19:32","nodeType":"VariableDeclaration","scope":5224,"src":"14269:27:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5214,"name":"uint256","nodeType":"ElementaryTypeName","src":"14269:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5217,"mutability":"mutable","name":"amountWrappedRaw","nameLocation":"14314:16:32","nodeType":"VariableDeclaration","scope":5224,"src":"14306:24:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5216,"name":"uint256","nodeType":"ElementaryTypeName","src":"14306:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5219,"mutability":"mutable","name":"sharesOwner","nameLocation":"14348:11:32","nodeType":"VariableDeclaration","scope":5224,"src":"14340:19:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5218,"name":"address","nodeType":"ElementaryTypeName","src":"14340:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"14228:137:32"},"returnParameters":{"id":5223,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5222,"mutability":"mutable","name":"issuedShares","nameLocation":"14392:12:32","nodeType":"VariableDeclaration","scope":5224,"src":"14384:20:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5221,"name":"uint256","nodeType":"ElementaryTypeName","src":"14384:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"14383:22:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5239,"nodeType":"FunctionDefinition","src":"15124:205:32","nodes":[],"documentation":{"id":5225,"nodeType":"StructuredDocumentation","src":"14412:707:32","text":" @notice Adds liquidity to an internal ERC4626 buffer in the Vault, proportionally.\n @dev The buffer needs to be initialized beforehand.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @param exactSharesToIssue The value in underlying tokens that `sharesOwner` wants to add to the buffer,\n in underlying token decimals\n @param sharesOwner Address that will own the deposited liquidity. Only this address will be able to remove\n liquidity from the buffer\n @return amountUnderlyingRaw Amount of underlying tokens deposited into the buffer\n @return amountWrappedRaw Amount of wrapped tokens deposited into the buffer"},"functionSelector":"d446e4a6","implemented":false,"kind":"function","modifiers":[],"name":"addLiquidityToBuffer","nameLocation":"15133:20:32","parameters":{"id":5233,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5228,"mutability":"mutable","name":"wrappedToken","nameLocation":"15172:12:32","nodeType":"VariableDeclaration","scope":5239,"src":"15163:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5227,"nodeType":"UserDefinedTypeName","pathNode":{"id":5226,"name":"IERC4626","nameLocations":["15163:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"15163:8:32"},"referencedDeclaration":51483,"src":"15163:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"},{"constant":false,"id":5230,"mutability":"mutable","name":"exactSharesToIssue","nameLocation":"15202:18:32","nodeType":"VariableDeclaration","scope":5239,"src":"15194:26:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5229,"name":"uint256","nodeType":"ElementaryTypeName","src":"15194:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5232,"mutability":"mutable","name":"sharesOwner","nameLocation":"15238:11:32","nodeType":"VariableDeclaration","scope":5239,"src":"15230:19:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5231,"name":"address","nodeType":"ElementaryTypeName","src":"15230:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"15153:102:32"},"returnParameters":{"id":5238,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5235,"mutability":"mutable","name":"amountUnderlyingRaw","nameLocation":"15282:19:32","nodeType":"VariableDeclaration","scope":5239,"src":"15274:27:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5234,"name":"uint256","nodeType":"ElementaryTypeName","src":"15274:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5237,"mutability":"mutable","name":"amountWrappedRaw","nameLocation":"15311:16:32","nodeType":"VariableDeclaration","scope":5239,"src":"15303:24:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5236,"name":"uint256","nodeType":"ElementaryTypeName","src":"15303:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"15273:55:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5252,"nodeType":"FunctionDefinition","src":"16482:193:32","nodes":[],"documentation":{"id":5240,"nodeType":"StructuredDocumentation","src":"15335:1142:32","text":" @notice Removes liquidity from an internal ERC4626 buffer in the Vault.\n @dev Only proportional exits are supported, and the sender has to be the owner of the shares.\n This function unlocks the Vault just for this operation; it does not work with a Router as an entrypoint.\n Pre-conditions:\n - The buffer needs to be initialized.\n - sharesOwner is the original msg.sender, it needs to be checked in the Router. That's why\n   this call is authenticated; only routers approved by the DAO can remove the liquidity of a buffer.\n - The buffer needs to have some liquidity and have its asset registered in `_bufferAssets` storage.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @param sharesToRemove Amount of shares to remove from the buffer. Cannot be greater than sharesOwner's\n total shares. It is expressed in underlying token native decimals.\n @return removedUnderlyingBalanceRaw Amount of underlying tokens returned to the user\n @return removedWrappedBalanceRaw Amount of wrapped tokens returned to the user"},"functionSelector":"35b60a19","implemented":false,"kind":"function","modifiers":[],"name":"removeLiquidityFromBuffer","nameLocation":"16491:25:32","parameters":{"id":5246,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5243,"mutability":"mutable","name":"wrappedToken","nameLocation":"16535:12:32","nodeType":"VariableDeclaration","scope":5252,"src":"16526:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5242,"nodeType":"UserDefinedTypeName","pathNode":{"id":5241,"name":"IERC4626","nameLocations":["16526:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"16526:8:32"},"referencedDeclaration":51483,"src":"16526:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"},{"constant":false,"id":5245,"mutability":"mutable","name":"sharesToRemove","nameLocation":"16565:14:32","nodeType":"VariableDeclaration","scope":5252,"src":"16557:22:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5244,"name":"uint256","nodeType":"ElementaryTypeName","src":"16557:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"16516:69:32"},"returnParameters":{"id":5251,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5248,"mutability":"mutable","name":"removedUnderlyingBalanceRaw","nameLocation":"16612:27:32","nodeType":"VariableDeclaration","scope":5252,"src":"16604:35:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5247,"name":"uint256","nodeType":"ElementaryTypeName","src":"16604:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5250,"mutability":"mutable","name":"removedWrappedBalanceRaw","nameLocation":"16649:24:32","nodeType":"VariableDeclaration","scope":5252,"src":"16641:32:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5249,"name":"uint256","nodeType":"ElementaryTypeName","src":"16641:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"16603:71:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"},{"id":5261,"nodeType":"FunctionDefinition","src":"17068:95:32","nodes":[],"documentation":{"id":5253,"nodeType":"StructuredDocumentation","src":"16681:382:32","text":" @notice Returns the asset registered for a given wrapped token.\n @dev The asset can never change after buffer initialization.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @return underlyingToken Address of the underlying token registered for the wrapper; `address(0)` if the buffer\n has not been initialized."},"functionSelector":"0387587d","implemented":false,"kind":"function","modifiers":[],"name":"getBufferAsset","nameLocation":"17077:14:32","parameters":{"id":5257,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5256,"mutability":"mutable","name":"wrappedToken","nameLocation":"17101:12:32","nodeType":"VariableDeclaration","scope":5261,"src":"17092:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5255,"nodeType":"UserDefinedTypeName","pathNode":{"id":5254,"name":"IERC4626","nameLocations":["17092:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"17092:8:32"},"referencedDeclaration":51483,"src":"17092:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"}],"src":"17091:23:32"},"returnParameters":{"id":5260,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5259,"mutability":"mutable","name":"underlyingToken","nameLocation":"17146:15:32","nodeType":"VariableDeclaration","scope":5261,"src":"17138:23:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5258,"name":"address","nodeType":"ElementaryTypeName","src":"17138:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"17137:25:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5272,"nodeType":"FunctionDefinition","src":"17615:143:32","nodes":[],"documentation":{"id":5262,"nodeType":"StructuredDocumentation","src":"17169:441:32","text":" @notice Returns the shares (internal buffer BPT) of a liquidity owner: a user that deposited assets\n in the buffer.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @param liquidityOwner Address of the user that owns liquidity in the wrapped token's buffer\n @return ownerShares Amount of shares allocated to the liquidity owner, in native underlying token decimals"},"functionSelector":"9385e39a","implemented":false,"kind":"function","modifiers":[],"name":"getBufferOwnerShares","nameLocation":"17624:20:32","parameters":{"id":5268,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5265,"mutability":"mutable","name":"wrappedToken","nameLocation":"17663:12:32","nodeType":"VariableDeclaration","scope":5272,"src":"17654:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5264,"nodeType":"UserDefinedTypeName","pathNode":{"id":5263,"name":"IERC4626","nameLocations":["17654:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"17654:8:32"},"referencedDeclaration":51483,"src":"17654:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"},{"constant":false,"id":5267,"mutability":"mutable","name":"liquidityOwner","nameLocation":"17693:14:32","nodeType":"VariableDeclaration","scope":5272,"src":"17685:22:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"},"typeName":{"id":5266,"name":"address","nodeType":"ElementaryTypeName","src":"17685:7:32","stateMutability":"nonpayable","typeDescriptions":{"typeIdentifier":"t_address","typeString":"address"}},"visibility":"internal"}],"src":"17644:69:32"},"returnParameters":{"id":5271,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5270,"mutability":"mutable","name":"ownerShares","nameLocation":"17745:11:32","nodeType":"VariableDeclaration","scope":5272,"src":"17737:19:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5269,"name":"uint256","nodeType":"ElementaryTypeName","src":"17737:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"17736:21:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5281,"nodeType":"FunctionDefinition","src":"18050:98:32","nodes":[],"documentation":{"id":5273,"nodeType":"StructuredDocumentation","src":"17764:281:32","text":" @notice Returns the supply shares (internal buffer BPT) of the ERC4626 buffer.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @return bufferShares Amount of supply shares of the buffer, in native underlying token decimals"},"functionSelector":"f2784e07","implemented":false,"kind":"function","modifiers":[],"name":"getBufferTotalShares","nameLocation":"18059:20:32","parameters":{"id":5277,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5276,"mutability":"mutable","name":"wrappedToken","nameLocation":"18089:12:32","nodeType":"VariableDeclaration","scope":5281,"src":"18080:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5275,"nodeType":"UserDefinedTypeName","pathNode":{"id":5274,"name":"IERC4626","nameLocations":["18080:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"18080:8:32"},"referencedDeclaration":51483,"src":"18080:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"}],"src":"18079:23:32"},"returnParameters":{"id":5280,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5279,"mutability":"mutable","name":"bufferShares","nameLocation":"18134:12:32","nodeType":"VariableDeclaration","scope":5281,"src":"18126:20:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5278,"name":"uint256","nodeType":"ElementaryTypeName","src":"18126:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"18125:22:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5292,"nodeType":"FunctionDefinition","src":"18680:143:32","nodes":[],"documentation":{"id":5282,"nodeType":"StructuredDocumentation","src":"18154:521:32","text":" @notice Returns the amount of underlying and wrapped tokens deposited in the internal buffer of the Vault.\n @dev All values are in native token decimals of the wrapped or underlying tokens.\n @param wrappedToken Address of the wrapped token that implements IERC4626\n @return underlyingBalanceRaw Amount of underlying tokens deposited into the buffer, in native token decimals\n @return wrappedBalanceRaw Amount of wrapped tokens deposited into the buffer, in native token decimals"},"functionSelector":"4021fe0f","implemented":false,"kind":"function","modifiers":[],"name":"getBufferBalance","nameLocation":"18689:16:32","parameters":{"id":5286,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5285,"mutability":"mutable","name":"wrappedToken","nameLocation":"18724:12:32","nodeType":"VariableDeclaration","scope":5292,"src":"18715:21:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"},"typeName":{"id":5284,"nodeType":"UserDefinedTypeName","pathNode":{"id":5283,"name":"IERC4626","nameLocations":["18715:8:32"],"nodeType":"IdentifierPath","referencedDeclaration":51483,"src":"18715:8:32"},"referencedDeclaration":51483,"src":"18715:8:32","typeDescriptions":{"typeIdentifier":"t_contract$_IERC4626_$51483","typeString":"contract IERC4626"}},"visibility":"internal"}],"src":"18705:37:32"},"returnParameters":{"id":5291,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5288,"mutability":"mutable","name":"underlyingBalanceRaw","nameLocation":"18774:20:32","nodeType":"VariableDeclaration","scope":5292,"src":"18766:28:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5287,"name":"uint256","nodeType":"ElementaryTypeName","src":"18766:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"},{"constant":false,"id":5290,"mutability":"mutable","name":"wrappedBalanceRaw","nameLocation":"18804:17:32","nodeType":"VariableDeclaration","scope":5292,"src":"18796:25:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"},"typeName":{"id":5289,"name":"uint256","nodeType":"ElementaryTypeName","src":"18796:7:32","typeDescriptions":{"typeIdentifier":"t_uint256","typeString":"uint256"}},"visibility":"internal"}],"src":"18765:57:32"},"scope":5300,"stateMutability":"view","virtual":false,"visibility":"external"},{"id":5299,"nodeType":"FunctionDefinition","src":"19254:59:32","nodes":[],"documentation":{"id":5293,"nodeType":"StructuredDocumentation","src":"19047:202:32","text":" @notice Sets a new Authorizer for the Vault.\n @dev This is a permissioned call. Emits an `AuthorizerChanged` event.\n @param newAuthorizer The address of the new authorizer"},"functionSelector":"058a628f","implemented":false,"kind":"function","modifiers":[],"name":"setAuthorizer","nameLocation":"19263:13:32","parameters":{"id":5297,"nodeType":"ParameterList","parameters":[{"constant":false,"id":5296,"mutability":"mutable","name":"newAuthorizer","nameLocation":"19289:13:32","nodeType":"VariableDeclaration","scope":5299,"src":"19277:25:32","stateVariable":false,"storageLocation":"default","typeDescriptions":{"typeIdentifier":"t_contract$_IAuthorizer_$3638","typeString":"contract IAuthorizer"},"typeName":{"id":5295,"nodeType":"UserDefinedTypeName","pathNode":{"id":5294,"name":"IAuthorizer","nameLocations":["19277:11:32"],"nodeType":"IdentifierPath","referencedDeclaration":3638,"src":"19277:11:32"},"referencedDeclaration":3638,"src":"19277:11:32","typeDescriptions":{"typeIdentifier":"t_contract$_IAuthorizer_$3638","typeString":"contract IAuthorizer"}},"visibility":"internal"}],"src":"19276:27:32"},"returnParameters":{"id":5298,"nodeType":"ParameterList","parameters":[],"src":"19312:0:32"},"scope":5300,"stateMutability":"nonpayable","virtual":false,"visibility":"external"}],"abstract":false,"baseContracts":[],"canonicalName":"IVaultAdmin","contractDependencies":[],"contractKind":"interface","documentation":{"id":5039,"nodeType":"StructuredDocumentation","src":"309:276:32","text":" @notice Interface for functions defined on the `VaultAdmin` contract.\n @dev `VaultAdmin` is the Proxy extension of `VaultExtension`, and handles the least critical operations,\n as two delegate calls add gas to each call. Most of the permissioned calls are here."},"fullyImplemented":false,"linearizedBaseContracts":[5300],"name":"IVaultAdmin","nameLocation":"596:11:32","scope":5301,"usedErrors":[],"usedEvents":[]}],"license":"GPL-3.0-or-later"},"id":32}