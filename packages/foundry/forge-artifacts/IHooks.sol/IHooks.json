{"abi":[{"type":"function","name":"getHookFlags","inputs":[],"outputs":[{"name":"hookFlags","type":"tuple","internalType":"struct HookFlags","components":[{"name":"enableHookAdjustedAmounts","type":"bool","internalType":"bool"},{"name":"shouldCallBeforeInitialize","type":"bool","internalType":"bool"},{"name":"shouldCallAfterInitialize","type":"bool","internalType":"bool"},{"name":"shouldCallComputeDynamicSwapFee","type":"bool","internalType":"bool"},{"name":"shouldCallBeforeSwap","type":"bool","internalType":"bool"},{"name":"shouldCallAfterSwap","type":"bool","internalType":"bool"},{"name":"shouldCallBeforeAddLiquidity","type":"bool","internalType":"bool"},{"name":"shouldCallAfterAddLiquidity","type":"bool","internalType":"bool"},{"name":"shouldCallBeforeRemoveLiquidity","type":"bool","internalType":"bool"},{"name":"shouldCallAfterRemoveLiquidity","type":"bool","internalType":"bool"}]}],"stateMutability":"view"},{"type":"function","name":"onAfterAddLiquidity","inputs":[{"name":"router","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"kind","type":"uint8","internalType":"enum AddLiquidityKind"},{"name":"amountsInScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"amountsInRaw","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmountOut","type":"uint256","internalType":"uint256"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"},{"name":"hookAdjustedAmountsInRaw","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"nonpayable"},{"type":"function","name":"onAfterInitialize","inputs":[{"name":"exactAmountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmountOut","type":"uint256","internalType":"uint256"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"onAfterRemoveLiquidity","inputs":[{"name":"router","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"kind","type":"uint8","internalType":"enum RemoveLiquidityKind"},{"name":"bptAmountIn","type":"uint256","internalType":"uint256"},{"name":"amountsOutScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"amountsOutRaw","type":"uint256[]","internalType":"uint256[]"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"},{"name":"hookAdjustedAmountsOutRaw","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"nonpayable"},{"type":"function","name":"onAfterSwap","inputs":[{"name":"params","type":"tuple","internalType":"struct AfterSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"tokenIn","type":"address","internalType":"contract IERC20"},{"name":"tokenOut","type":"address","internalType":"contract IERC20"},{"name":"amountInScaled18","type":"uint256","internalType":"uint256"},{"name":"amountOutScaled18","type":"uint256","internalType":"uint256"},{"name":"tokenInBalanceScaled18","type":"uint256","internalType":"uint256"},{"name":"tokenOutBalanceScaled18","type":"uint256","internalType":"uint256"},{"name":"amountCalculatedScaled18","type":"uint256","internalType":"uint256"},{"name":"amountCalculatedRaw","type":"uint256","internalType":"uint256"},{"name":"router","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"userData","type":"bytes","internalType":"bytes"}]}],"outputs":[{"name":"success","type":"bool","internalType":"bool"},{"name":"hookAdjustedAmountCalculatedRaw","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"onBeforeAddLiquidity","inputs":[{"name":"router","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"kind","type":"uint8","internalType":"enum AddLiquidityKind"},{"name":"maxAmountsInScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"minBptAmountOut","type":"uint256","internalType":"uint256"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"onBeforeInitialize","inputs":[{"name":"exactAmountsIn","type":"uint256[]","internalType":"uint256[]"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"onBeforeRemoveLiquidity","inputs":[{"name":"router","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"kind","type":"uint8","internalType":"enum RemoveLiquidityKind"},{"name":"maxBptAmountIn","type":"uint256","internalType":"uint256"},{"name":"minAmountsOutScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"userData","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"onBeforeSwap","inputs":[{"name":"params","type":"tuple","internalType":"struct PoolSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"amountGivenScaled18","type":"uint256","internalType":"uint256"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"indexIn","type":"uint256","internalType":"uint256"},{"name":"indexOut","type":"uint256","internalType":"uint256"},{"name":"router","type":"address","internalType":"address"},{"name":"userData","type":"bytes","internalType":"bytes"}]},{"name":"pool","type":"address","internalType":"address"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"},{"type":"function","name":"onComputeDynamicSwapFeePercentage","inputs":[{"name":"params","type":"tuple","internalType":"struct PoolSwapParams","components":[{"name":"kind","type":"uint8","internalType":"enum SwapKind"},{"name":"amountGivenScaled18","type":"uint256","internalType":"uint256"},{"name":"balancesScaled18","type":"uint256[]","internalType":"uint256[]"},{"name":"indexIn","type":"uint256","internalType":"uint256"},{"name":"indexOut","type":"uint256","internalType":"uint256"},{"name":"router","type":"address","internalType":"address"},{"name":"userData","type":"bytes","internalType":"bytes"}]},{"name":"pool","type":"address","internalType":"address"},{"name":"staticSwapFeePercentage","type":"uint256","internalType":"uint256"}],"outputs":[{"name":"success","type":"bool","internalType":"bool"},{"name":"dynamicSwapFeePercentage","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"onRegister","inputs":[{"name":"factory","type":"address","internalType":"address"},{"name":"pool","type":"address","internalType":"address"},{"name":"tokenConfig","type":"tuple[]","internalType":"struct TokenConfig[]","components":[{"name":"token","type":"address","internalType":"contract IERC20"},{"name":"tokenType","type":"uint8","internalType":"enum TokenType"},{"name":"rateProvider","type":"address","internalType":"contract IRateProvider"},{"name":"paysYieldFees","type":"bool","internalType":"bool"}]},{"name":"liquidityManagement","type":"tuple","internalType":"struct LiquidityManagement","components":[{"name":"disableUnbalancedLiquidity","type":"bool","internalType":"bool"},{"name":"enableAddLiquidityCustom","type":"bool","internalType":"bool"},{"name":"enableRemoveLiquidityCustom","type":"bool","internalType":"bool"},{"name":"enableDonation","type":"bool","internalType":"bool"}]}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"nonpayable"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"getHookFlags()":"d77153a7","onAfterAddLiquidity(address,address,uint8,uint256[],uint256[],uint256,uint256[],bytes)":"976907cc","onAfterInitialize(uint256[],uint256,bytes)":"38be241d","onAfterRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],uint256[],bytes)":"2754888d","onAfterSwap((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,address,bytes))":"18b6eb55","onBeforeAddLiquidity(address,address,uint8,uint256[],uint256,uint256[],bytes)":"45421ec7","onBeforeInitialize(uint256[],bytes)":"1c149e28","onBeforeRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],bytes)":"ba5f9f40","onBeforeSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes),address)":"5211fa77","onComputeDynamicSwapFeePercentage((uint8,uint256,uint256[],uint256,uint256,address,bytes),address,uint256)":"a0e8f5ac","onRegister(address,address,(address,uint8,address,bool)[],(bool,bool,bool,bool))":"0b89f182"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"getHookFlags\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableHookAdjustedAmounts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallBeforeInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallAfterInitialize\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallComputeDynamicSwapFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallBeforeSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallAfterSwap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallBeforeAddLiquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallAfterAddLiquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallBeforeRemoveLiquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"shouldCallAfterRemoveLiquidity\",\"type\":\"bool\"}],\"internalType\":\"struct HookFlags\",\"name\":\"hookFlags\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum AddLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInRaw\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onAfterAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"hookAdjustedAmountsInRaw\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"exactAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onAfterInitialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum RemoveLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"bptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOutScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOutRaw\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onAfterRemoveLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"hookAdjustedAmountsOutRaw\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenInBalanceScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutBalanceScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCalculatedScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountCalculatedRaw\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct AfterSwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"onAfterSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"hookAdjustedAmountCalculatedRaw\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum AddLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsInScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minBptAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onBeforeAddLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"exactAmountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onBeforeInitialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"enum RemoveLiquidityKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxBptAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOutScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"onBeforeRemoveLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"indexIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolSwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"onBeforeSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountGivenScaled18\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"balancesScaled18\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"indexIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct PoolSwapParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"staticSwapFeePercentage\",\"type\":\"uint256\"}],\"name\":\"onComputeDynamicSwapFeePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"dynamicSwapFeePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"enum TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"contract IRateProvider\",\"name\":\"rateProvider\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paysYieldFees\",\"type\":\"bool\"}],\"internalType\":\"struct TokenConfig[]\",\"name\":\"tokenConfig\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"disableUnbalancedLiquidity\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enableAddLiquidityCustom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enableRemoveLiquidityCustom\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enableDonation\",\"type\":\"bool\"}],\"internalType\":\"struct LiquidityManagement\",\"name\":\"liquidityManagement\",\"type\":\"tuple\"}],\"name\":\"onRegister\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Hooks are functions invoked by the Vault at specific points in the flow of each operation. This guarantees that they are called in the correct order, and with the correct arguments. To maintain this security, these functions should only be called by the Vault. The recommended way to do this is to derive the hook contract from `BaseHooks`, then use the `onlyVault` modifier from `VaultGuard`. (See the examples in /pool-hooks.)\",\"kind\":\"dev\",\"methods\":{\"getHookFlags()\":{\"details\":\"The Vault will only call hooks the pool says it supports, and of course only if a hooks contract is defined (i.e., the `poolHooksContract` in `PoolRegistrationParams` is non-zero). `onRegister` is the only \\\"mandatory\\\" hook.\",\"returns\":{\"hookFlags\":\"Flags indicating which hooks the contract supports\"}},\"onAfterAddLiquidity(address,address,uint8,uint256[],uint256[],uint256,uint256[],bytes)\":{\"details\":\"Called if the `shouldCallAfterAddLiquidity` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountsInRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"amountsInRaw\":\"Actual amounts of tokens added, sorted in token registration order\",\"amountsInScaled18\":\"Actual amounts of tokens added, sorted in token registration order\",\"balancesScaled18\":\"Current pool balances, sorted in token registration order\",\"bptAmountOut\":\"Amount of pool tokens minted\",\"kind\":\"The type of add liquidity operation (e.g., proportional, custom)\",\"pool\":\"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)\",\"router\":\"The address (usually a router contract) that initiated an add liquidity operation on the Vault\",\"userData\":\"Additional (optional) data provided by the user\"},\"returns\":{\"hookAdjustedAmountsInRaw\":\"New amountsInRaw, potentially modified by the hook\",\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onAfterInitialize(uint256[],uint256,bytes)\":{\"details\":\"Called if the `shouldCallAfterInitialize` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"bptAmountOut\":\"Amount of pool tokens minted during initialization\",\"exactAmountsIn\":\"Exact amounts of input tokens\",\"userData\":\"Optional, arbitrary data sent with the encoded request\"},\"returns\":{\"_0\":\"success True if the pool accepts the initialization results\"}},\"onAfterRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],uint256[],bytes)\":{\"details\":\"Called if the `shouldCallAfterRemoveLiquidity` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountsOutRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"amountsOutRaw\":\"Actual amount of tokens to receive, sorted in token registration order\",\"amountsOutScaled18\":\"Scaled amount of tokens to receive, sorted in token registration order\",\"balancesScaled18\":\"Current pool balances, sorted in token registration order\",\"bptAmountIn\":\"Amount of pool tokens to burn\",\"kind\":\"The type of remove liquidity operation (e.g., proportional, custom)\",\"pool\":\"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)\",\"router\":\"The address (usually a router contract) that initiated a remove liquidity operation on the Vault\",\"userData\":\"Additional (optional) data provided by the user\"},\"returns\":{\"hookAdjustedAmountsOutRaw\":\"New amountsOutRaw, potentially modified by the hook\",\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onAfterSwap((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,address,bytes))\":{\"details\":\"Called if the `shouldCallAfterSwap` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountCalculatedRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"params\":\"Swap parameters (see above for struct definition)\"},\"returns\":{\"hookAdjustedAmountCalculatedRaw\":\"New amount calculated, potentially modified by the hook\",\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onBeforeAddLiquidity(address,address,uint8,uint256[],uint256,uint256[],bytes)\":{\"details\":\"Called if the `shouldCallBeforeAddLiquidity` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"balancesScaled18\":\"Current pool balances, sorted in token registration order\",\"kind\":\"The type of add liquidity operation (e.g., proportional, custom)\",\"maxAmountsInScaled18\":\"Maximum amounts of input tokens\",\"minBptAmountOut\":\"Minimum amount of output pool tokens\",\"pool\":\"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)\",\"router\":\"The address (usually a router contract) that initiated an add liquidity operation on the Vault\",\"userData\":\"Optional, arbitrary data sent with the encoded request\"},\"returns\":{\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onBeforeInitialize(uint256[],bytes)\":{\"details\":\"Called if the `shouldCallBeforeInitialize` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"exactAmountsIn\":\"Exact amounts of input tokens\",\"userData\":\"Optional, arbitrary data sent with the encoded request\"},\"returns\":{\"_0\":\"success True if the pool wishes to proceed with initialization\"}},\"onBeforeRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],bytes)\":{\"details\":\"Called if the `shouldCallBeforeRemoveLiquidity` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"balancesScaled18\":\"Current pool balances, sorted in token registration order\",\"kind\":\"The type of remove liquidity operation (e.g., proportional, custom)\",\"maxBptAmountIn\":\"Maximum amount of input pool tokens\",\"minAmountsOutScaled18\":\"Minimum output amounts, sorted in token registration order\",\"pool\":\"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)\",\"router\":\"The address (usually a router contract) that initiated a remove liquidity operation on the Vault\",\"userData\":\"Optional, arbitrary data sent with the encoded request\"},\"returns\":{\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onBeforeSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes),address)\":{\"details\":\"Called if the `shouldCallBeforeSwap` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"params\":\"Swap parameters (see PoolSwapParams for struct definition)\",\"pool\":\"Pool address, used to get pool information from the Vault (poolData, token config, etc.)\"},\"returns\":{\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onComputeDynamicSwapFeePercentage((uint8,uint256,uint256[],uint256,uint256,address,bytes),address,uint256)\":{\"details\":\"Called if the `shouldCallComputeDynamicSwapFee` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.\",\"params\":{\"params\":\"Swap parameters (see PoolSwapParams for struct definition)\",\"pool\":\"Pool address, used to get pool information from the Vault (poolData, token config, etc.)\",\"staticSwapFeePercentage\":\"18-decimal FP value of the static swap fee percentage, for reference\"},\"returns\":{\"dynamicSwapFeePercentage\":\"Value of the swap fee percentage, as an 18-decimal FP value\",\"success\":\"True if the pool wishes to proceed with settlement\"}},\"onRegister(address,address,(address,uint8,address,bool)[],(bool,bool,bool,bool))\":{\"details\":\"Returns true if registration was successful, and false to revert the pool registration. Make sure this function is properly implemented (e.g. check the factory, and check that the given pool is from the factory). The Vault address will be msg.sender.\",\"params\":{\"factory\":\"Address of the pool factory (contract deploying the pool)\",\"liquidityManagement\":\"Liquidity management flags indicating which functions are enabled\",\"pool\":\"Address of the pool\",\"tokenConfig\":\"An array of descriptors for the tokens the pool will manage\"},\"returns\":{\"_0\":\"success True if the hook allowed the registration, false otherwise\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getHookFlags()\":{\"notice\":\"Return the set of hooks implemented by the contract.\"},\"onAfterAddLiquidity(address,address,uint8,uint256[],uint256[],uint256,uint256[],bytes)\":{\"notice\":\"Hook to be executed after adding liquidity.\"},\"onAfterInitialize(uint256[],uint256,bytes)\":{\"notice\":\"Hook to be executed after pool initialization.\"},\"onAfterRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],uint256[],bytes)\":{\"notice\":\"Hook to be executed after removing liquidity.\"},\"onAfterSwap((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,address,bytes))\":{\"notice\":\"Called after a swap to perform further actions once the balances have been updated by the swap.\"},\"onBeforeAddLiquidity(address,address,uint8,uint256[],uint256,uint256[],bytes)\":{\"notice\":\"Hook to be executed before adding liquidity.\"},\"onBeforeInitialize(uint256[],bytes)\":{\"notice\":\"Hook executed before pool initialization.\"},\"onBeforeRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],bytes)\":{\"notice\":\"Hook to be executed before removing liquidity.\"},\"onBeforeSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes),address)\":{\"notice\":\"Called before a swap to give the Pool an opportunity to perform actions.\"},\"onComputeDynamicSwapFeePercentage((uint8,uint256,uint256[],uint256,uint256,address,bytes),address,uint256)\":{\"notice\":\"Called after `onBeforeSwap` and before the main swap operation, if the pool has dynamic fees.\"},\"onRegister(address,address,(address,uint8,address,bool)[],(bool,bool,bool,bool))\":{\"notice\":\"Hook executed when a pool is registered with a non-zero hooks contract.\"}},\"notice\":\"Interface for pool hooks.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol\":\"IHooks\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":999},\"remappings\":[\":@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/\",\":@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/\",\":@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/\",\":@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/\",\":@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/\",\":@openzeppelin/=lib/openzeppelin-contracts/\",\":@test/=lib/balancer-v3-monorepo/pkg/\",\":ds-test/=../../node_modules/forge-std/lib/ds-test/src/\",\":forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/\",\":forge-std/=lib/forge-std/src/\",\":permit2/=lib/permit2/\",\":pool-weighted/=../pool-weighted/\",\":solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\",\":solidity-utils/=../solidity-utils/\",\":vault/=../vault/\"]},\"sources\":{\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol\":{\"keccak256\":\"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452\",\"dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol\":{\"keccak256\":\"0x90f77758dbdfdb952754aa3fbfbdf816afb9592b49a12932cf6636bb6dab6638\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://bf3a76192ee4290f81c33dcc28889761087b0f3f5324bdf0c5487504a349df5f\",\"dweb:/ipfs/QmX5tH5yox4riErpQ43BEmc7L11C65ob53gRQ5VUBdNM3Y\"]},\"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol\":{\"keccak256\":\"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3\",\"license\":\"GPL-3.0-or-later\",\"urls\":[\"bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3\",\"dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf\"]},\"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol\":{\"keccak256\":\"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf\",\"dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009\",\"dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"keccak256\":\"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323\",\"dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.24+commit.e11b9ed9"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"view","type":"function","name":"getHookFlags","outputs":[{"internalType":"struct HookFlags","name":"hookFlags","type":"tuple","components":[{"internalType":"bool","name":"enableHookAdjustedAmounts","type":"bool"},{"internalType":"bool","name":"shouldCallBeforeInitialize","type":"bool"},{"internalType":"bool","name":"shouldCallAfterInitialize","type":"bool"},{"internalType":"bool","name":"shouldCallComputeDynamicSwapFee","type":"bool"},{"internalType":"bool","name":"shouldCallBeforeSwap","type":"bool"},{"internalType":"bool","name":"shouldCallAfterSwap","type":"bool"},{"internalType":"bool","name":"shouldCallBeforeAddLiquidity","type":"bool"},{"internalType":"bool","name":"shouldCallAfterAddLiquidity","type":"bool"},{"internalType":"bool","name":"shouldCallBeforeRemoveLiquidity","type":"bool"},{"internalType":"bool","name":"shouldCallAfterRemoveLiquidity","type":"bool"}]}]},{"inputs":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"enum AddLiquidityKind","name":"kind","type":"uint8"},{"internalType":"uint256[]","name":"amountsInScaled18","type":"uint256[]"},{"internalType":"uint256[]","name":"amountsInRaw","type":"uint256[]"},{"internalType":"uint256","name":"bptAmountOut","type":"uint256"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onAfterAddLiquidity","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"uint256[]","name":"hookAdjustedAmountsInRaw","type":"uint256[]"}]},{"inputs":[{"internalType":"uint256[]","name":"exactAmountsIn","type":"uint256[]"},{"internalType":"uint256","name":"bptAmountOut","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onAfterInitialize","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"enum RemoveLiquidityKind","name":"kind","type":"uint8"},{"internalType":"uint256","name":"bptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"amountsOutScaled18","type":"uint256[]"},{"internalType":"uint256[]","name":"amountsOutRaw","type":"uint256[]"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onAfterRemoveLiquidity","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"uint256[]","name":"hookAdjustedAmountsOutRaw","type":"uint256[]"}]},{"inputs":[{"internalType":"struct AfterSwapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"contract IERC20","name":"tokenIn","type":"address"},{"internalType":"contract IERC20","name":"tokenOut","type":"address"},{"internalType":"uint256","name":"amountInScaled18","type":"uint256"},{"internalType":"uint256","name":"amountOutScaled18","type":"uint256"},{"internalType":"uint256","name":"tokenInBalanceScaled18","type":"uint256"},{"internalType":"uint256","name":"tokenOutBalanceScaled18","type":"uint256"},{"internalType":"uint256","name":"amountCalculatedScaled18","type":"uint256"},{"internalType":"uint256","name":"amountCalculatedRaw","type":"uint256"},{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"bytes","name":"userData","type":"bytes"}]}],"stateMutability":"nonpayable","type":"function","name":"onAfterSwap","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"uint256","name":"hookAdjustedAmountCalculatedRaw","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"enum AddLiquidityKind","name":"kind","type":"uint8"},{"internalType":"uint256[]","name":"maxAmountsInScaled18","type":"uint256[]"},{"internalType":"uint256","name":"minBptAmountOut","type":"uint256"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onBeforeAddLiquidity","outputs":[{"internalType":"bool","name":"success","type":"bool"}]},{"inputs":[{"internalType":"uint256[]","name":"exactAmountsIn","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onBeforeInitialize","outputs":[{"internalType":"bool","name":"","type":"bool"}]},{"inputs":[{"internalType":"address","name":"router","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"enum RemoveLiquidityKind","name":"kind","type":"uint8"},{"internalType":"uint256","name":"maxBptAmountIn","type":"uint256"},{"internalType":"uint256[]","name":"minAmountsOutScaled18","type":"uint256[]"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"stateMutability":"nonpayable","type":"function","name":"onBeforeRemoveLiquidity","outputs":[{"internalType":"bool","name":"success","type":"bool"}]},{"inputs":[{"internalType":"struct PoolSwapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"uint256","name":"amountGivenScaled18","type":"uint256"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"uint256","name":"indexIn","type":"uint256"},{"internalType":"uint256","name":"indexOut","type":"uint256"},{"internalType":"address","name":"router","type":"address"},{"internalType":"bytes","name":"userData","type":"bytes"}]},{"internalType":"address","name":"pool","type":"address"}],"stateMutability":"nonpayable","type":"function","name":"onBeforeSwap","outputs":[{"internalType":"bool","name":"success","type":"bool"}]},{"inputs":[{"internalType":"struct PoolSwapParams","name":"params","type":"tuple","components":[{"internalType":"enum SwapKind","name":"kind","type":"uint8"},{"internalType":"uint256","name":"amountGivenScaled18","type":"uint256"},{"internalType":"uint256[]","name":"balancesScaled18","type":"uint256[]"},{"internalType":"uint256","name":"indexIn","type":"uint256"},{"internalType":"uint256","name":"indexOut","type":"uint256"},{"internalType":"address","name":"router","type":"address"},{"internalType":"bytes","name":"userData","type":"bytes"}]},{"internalType":"address","name":"pool","type":"address"},{"internalType":"uint256","name":"staticSwapFeePercentage","type":"uint256"}],"stateMutability":"view","type":"function","name":"onComputeDynamicSwapFeePercentage","outputs":[{"internalType":"bool","name":"success","type":"bool"},{"internalType":"uint256","name":"dynamicSwapFeePercentage","type":"uint256"}]},{"inputs":[{"internalType":"address","name":"factory","type":"address"},{"internalType":"address","name":"pool","type":"address"},{"internalType":"struct TokenConfig[]","name":"tokenConfig","type":"tuple[]","components":[{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"enum TokenType","name":"tokenType","type":"uint8"},{"internalType":"contract IRateProvider","name":"rateProvider","type":"address"},{"internalType":"bool","name":"paysYieldFees","type":"bool"}]},{"internalType":"struct LiquidityManagement","name":"liquidityManagement","type":"tuple","components":[{"internalType":"bool","name":"disableUnbalancedLiquidity","type":"bool"},{"internalType":"bool","name":"enableAddLiquidityCustom","type":"bool"},{"internalType":"bool","name":"enableRemoveLiquidityCustom","type":"bool"},{"internalType":"bool","name":"enableDonation","type":"bool"}]}],"stateMutability":"nonpayable","type":"function","name":"onRegister","outputs":[{"internalType":"bool","name":"","type":"bool"}]}],"devdoc":{"kind":"dev","methods":{"getHookFlags()":{"details":"The Vault will only call hooks the pool says it supports, and of course only if a hooks contract is defined (i.e., the `poolHooksContract` in `PoolRegistrationParams` is non-zero). `onRegister` is the only \"mandatory\" hook.","returns":{"hookFlags":"Flags indicating which hooks the contract supports"}},"onAfterAddLiquidity(address,address,uint8,uint256[],uint256[],uint256,uint256[],bytes)":{"details":"Called if the `shouldCallAfterAddLiquidity` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountsInRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"amountsInRaw":"Actual amounts of tokens added, sorted in token registration order","amountsInScaled18":"Actual amounts of tokens added, sorted in token registration order","balancesScaled18":"Current pool balances, sorted in token registration order","bptAmountOut":"Amount of pool tokens minted","kind":"The type of add liquidity operation (e.g., proportional, custom)","pool":"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)","router":"The address (usually a router contract) that initiated an add liquidity operation on the Vault","userData":"Additional (optional) data provided by the user"},"returns":{"hookAdjustedAmountsInRaw":"New amountsInRaw, potentially modified by the hook","success":"True if the pool wishes to proceed with settlement"}},"onAfterInitialize(uint256[],uint256,bytes)":{"details":"Called if the `shouldCallAfterInitialize` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"bptAmountOut":"Amount of pool tokens minted during initialization","exactAmountsIn":"Exact amounts of input tokens","userData":"Optional, arbitrary data sent with the encoded request"},"returns":{"_0":"success True if the pool accepts the initialization results"}},"onAfterRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],uint256[],bytes)":{"details":"Called if the `shouldCallAfterRemoveLiquidity` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountsOutRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"amountsOutRaw":"Actual amount of tokens to receive, sorted in token registration order","amountsOutScaled18":"Scaled amount of tokens to receive, sorted in token registration order","balancesScaled18":"Current pool balances, sorted in token registration order","bptAmountIn":"Amount of pool tokens to burn","kind":"The type of remove liquidity operation (e.g., proportional, custom)","pool":"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)","router":"The address (usually a router contract) that initiated a remove liquidity operation on the Vault","userData":"Additional (optional) data provided by the user"},"returns":{"hookAdjustedAmountsOutRaw":"New amountsOutRaw, potentially modified by the hook","success":"True if the pool wishes to proceed with settlement"}},"onAfterSwap((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,address,bytes))":{"details":"Called if the `shouldCallAfterSwap` flag is set in the configuration. The Vault will ignore `hookAdjustedAmountCalculatedRaw` unless `enableHookAdjustedAmounts` is true. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"params":"Swap parameters (see above for struct definition)"},"returns":{"hookAdjustedAmountCalculatedRaw":"New amount calculated, potentially modified by the hook","success":"True if the pool wishes to proceed with settlement"}},"onBeforeAddLiquidity(address,address,uint8,uint256[],uint256,uint256[],bytes)":{"details":"Called if the `shouldCallBeforeAddLiquidity` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"balancesScaled18":"Current pool balances, sorted in token registration order","kind":"The type of add liquidity operation (e.g., proportional, custom)","maxAmountsInScaled18":"Maximum amounts of input tokens","minBptAmountOut":"Minimum amount of output pool tokens","pool":"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)","router":"The address (usually a router contract) that initiated an add liquidity operation on the Vault","userData":"Optional, arbitrary data sent with the encoded request"},"returns":{"success":"True if the pool wishes to proceed with settlement"}},"onBeforeInitialize(uint256[],bytes)":{"details":"Called if the `shouldCallBeforeInitialize` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"exactAmountsIn":"Exact amounts of input tokens","userData":"Optional, arbitrary data sent with the encoded request"},"returns":{"_0":"success True if the pool wishes to proceed with initialization"}},"onBeforeRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],bytes)":{"details":"Called if the `shouldCallBeforeRemoveLiquidity` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"balancesScaled18":"Current pool balances, sorted in token registration order","kind":"The type of remove liquidity operation (e.g., proportional, custom)","maxBptAmountIn":"Maximum amount of input pool tokens","minAmountsOutScaled18":"Minimum output amounts, sorted in token registration order","pool":"Pool address, used to fetch pool information from the Vault (pool config, tokens, etc.)","router":"The address (usually a router contract) that initiated a remove liquidity operation on the Vault","userData":"Optional, arbitrary data sent with the encoded request"},"returns":{"success":"True if the pool wishes to proceed with settlement"}},"onBeforeSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes),address)":{"details":"Called if the `shouldCallBeforeSwap` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"params":"Swap parameters (see PoolSwapParams for struct definition)","pool":"Pool address, used to get pool information from the Vault (poolData, token config, etc.)"},"returns":{"success":"True if the pool wishes to proceed with settlement"}},"onComputeDynamicSwapFeePercentage((uint8,uint256,uint256[],uint256,uint256,address,bytes),address,uint256)":{"details":"Called if the `shouldCallComputeDynamicSwapFee` flag is set in the configuration. Hook contracts should use the `onlyVault` modifier to guarantee this is only called by the Vault.","params":{"params":"Swap parameters (see PoolSwapParams for struct definition)","pool":"Pool address, used to get pool information from the Vault (poolData, token config, etc.)","staticSwapFeePercentage":"18-decimal FP value of the static swap fee percentage, for reference"},"returns":{"dynamicSwapFeePercentage":"Value of the swap fee percentage, as an 18-decimal FP value","success":"True if the pool wishes to proceed with settlement"}},"onRegister(address,address,(address,uint8,address,bool)[],(bool,bool,bool,bool))":{"details":"Returns true if registration was successful, and false to revert the pool registration. Make sure this function is properly implemented (e.g. check the factory, and check that the given pool is from the factory). The Vault address will be msg.sender.","params":{"factory":"Address of the pool factory (contract deploying the pool)","liquidityManagement":"Liquidity management flags indicating which functions are enabled","pool":"Address of the pool","tokenConfig":"An array of descriptors for the tokens the pool will manage"},"returns":{"_0":"success True if the hook allowed the registration, false otherwise"}}},"version":1},"userdoc":{"kind":"user","methods":{"getHookFlags()":{"notice":"Return the set of hooks implemented by the contract."},"onAfterAddLiquidity(address,address,uint8,uint256[],uint256[],uint256,uint256[],bytes)":{"notice":"Hook to be executed after adding liquidity."},"onAfterInitialize(uint256[],uint256,bytes)":{"notice":"Hook to be executed after pool initialization."},"onAfterRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],uint256[],bytes)":{"notice":"Hook to be executed after removing liquidity."},"onAfterSwap((uint8,address,address,uint256,uint256,uint256,uint256,uint256,uint256,address,address,bytes))":{"notice":"Called after a swap to perform further actions once the balances have been updated by the swap."},"onBeforeAddLiquidity(address,address,uint8,uint256[],uint256,uint256[],bytes)":{"notice":"Hook to be executed before adding liquidity."},"onBeforeInitialize(uint256[],bytes)":{"notice":"Hook executed before pool initialization."},"onBeforeRemoveLiquidity(address,address,uint8,uint256,uint256[],uint256[],bytes)":{"notice":"Hook to be executed before removing liquidity."},"onBeforeSwap((uint8,uint256,uint256[],uint256,uint256,address,bytes),address)":{"notice":"Called before a swap to give the Pool an opportunity to perform actions."},"onComputeDynamicSwapFeePercentage((uint8,uint256,uint256[],uint256,uint256,address,bytes),address,uint256)":{"notice":"Called after `onBeforeSwap` and before the main swap operation, if the pool has dynamic fees."},"onRegister(address,address,(address,uint8,address,bool)[],(bool,bool,bool,bool))":{"notice":"Hook executed when a pool is registered with a non-zero hooks contract."}},"version":1}},"settings":{"remappings":["@balancer-labs/v3-interfaces/=lib/balancer-v3-monorepo/pkg/interfaces/","@balancer-labs/v3-pool-utils/=lib/balancer-v3-monorepo/pkg/pool-utils/","@balancer-labs/v3-pool-weighted/=lib/balancer-v3-monorepo/pkg/pool-weighted/","@balancer-labs/v3-solidity-utils/=lib/balancer-v3-monorepo/pkg/solidity-utils/","@balancer-labs/v3-vault/=lib/balancer-v3-monorepo/pkg/vault/","@openzeppelin/=lib/openzeppelin-contracts/","@test/=lib/balancer-v3-monorepo/pkg/","ds-test/=../../node_modules/forge-std/lib/ds-test/src/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","permit2/=lib/permit2/","pool-weighted/=../pool-weighted/","solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/","solidity-utils/=../solidity-utils/","vault/=../vault/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"bytecodeHash":"ipfs"},"compilationTarget":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol":"IHooks"},"evmVersion":"cancun","libraries":{}},"sources":{"lib/balancer-v3-monorepo/pkg/interfaces/contracts/solidity-utils/helpers/IRateProvider.sol":{"keccak256":"0x910edf810a7b1f0bc24e0e539ad0c0f6f6e82643ab41349861144e1a456c4906","urls":["bzz-raw://96c2d6bcc42cba5cb5885e66323c42b99feaabddc3978df2297e26b029c14452","dweb:/ipfs/QmVinjNKFH5GBVtjaNjdBtnepHSGJBMJ64GJ3dpivtnCmc"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/IHooks.sol":{"keccak256":"0x90f77758dbdfdb952754aa3fbfbdf816afb9592b49a12932cf6636bb6dab6638","urls":["bzz-raw://bf3a76192ee4290f81c33dcc28889761087b0f3f5324bdf0c5487504a349df5f","dweb:/ipfs/QmX5tH5yox4riErpQ43BEmc7L11C65ob53gRQ5VUBdNM3Y"],"license":"GPL-3.0-or-later"},"lib/balancer-v3-monorepo/pkg/interfaces/contracts/vault/VaultTypes.sol":{"keccak256":"0xa617c556d3cfea9f5dd00a938e866418fe86fd1ed82c7edf0af9e0ab49bfbdc3","urls":["bzz-raw://ac8ac4d0d045d3e3270da4252eeccb4de2bb4cd50713c71c1ddbc1d9f3bb86d3","dweb:/ipfs/QmTgVAPthGjZSbd6dCczcRGSBeZJs4xbvyjAgWYB4rc6gf"],"license":"GPL-3.0-or-later"},"lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol":{"keccak256":"0x6423475004ac1c4db6e9f16908cbfb82e630f7868051869c6f89c7452facbc06","urls":["bzz-raw://bd31766a3235519db9207c02652e124746eef3e451271e82830090f9864ff4cf","dweb:/ipfs/QmNjjADM3vFELnFtiZJYuRRXEjQb8KP7cq6b8YqKww6Sdb"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"keccak256":"0xee2337af2dc162a973b4be6d3f7c16f06298259e0af48c5470d2839bfa8a22f4","urls":["bzz-raw://30c476b4b2f405c1bb3f0bae15b006d129c80f1bfd9d0f2038160a3bb9745009","dweb:/ipfs/Qmb3VcuDufv6xbHeVgksC4tHpc5gKYVqBEwjEXW72XzSvN"],"license":"MIT"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"keccak256":"0x88f7b6f070ad1de2bf899da6978ed74b5038eac78c01b7359b92b60c3d965c28","urls":["bzz-raw://c436edb6733a036607c6f17cc590e8ee351363a8cb4c564a98d9a66392c89323","dweb:/ipfs/QmcJvJR2K3EtYcKEXVpQ1WqT6TvAbVem5HR1FirAsqEXFR"],"license":"MIT"}},"version":1},"id":26}